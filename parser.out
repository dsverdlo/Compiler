Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    KEYWORD

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration program
Rule 2     program -> declaration
Rule 3     declaration -> fun_declaration
Rule 4     declaration -> var_declaration
Rule 5     fun_declaration -> type NAME LPAR formal_pars RPAR block
Rule 6     fun_declaration -> type NAME LPAR RPAR block
Rule 7     formal_pars -> formal_pars COMMA formal_par
Rule 8     formal_pars -> formal_par
Rule 9     formal_par -> type NAME
Rule 10    block -> LBRACE var_declarations statements RBRACE
Rule 11    block -> LBRACE var_declarations RBRACE
Rule 12    var_declarations -> var_declaration var_declarations
Rule 13    var_declarations -> empty
Rule 14    var_declaration -> type NAME SEMICOLON
Rule 15    type -> INT
Rule 16    type -> CHAR
Rule 17    type -> type LBRACK exp RBRACK
Rule 18    statements -> statements SEMICOLON statement
Rule 19    statements -> statement
Rule 20    statement -> block
Rule 21    statement -> RETURN exp
Rule 22    statement -> WRITE exp
Rule 23    statement -> READ lexp
Rule 24    statement -> NAME LPAR RPAR
Rule 25    statement -> NAME LPAR pars RPAR
Rule 26    statement -> WHILE LPAR exp RPAR statement
Rule 27    statement -> IF LPAR exp RPAR statement
Rule 28    statement -> IF LPAR exp RPAR statement ELSE statement
Rule 29    statement -> lexp ASSIGN exp
Rule 30    lexp -> var
Rule 31    lexp -> lexp LBRACK exp RBRACK
Rule 32    exp -> lexp
Rule 33    exp -> LENGTH lexp
Rule 34    exp -> unop exp
Rule 35    exp -> LPAR exp RPAR
Rule 36    exp -> NAME LPAR RPAR
Rule 37    exp -> NAME LPAR pars RPAR
Rule 38    exp -> NUMBER
Rule 39    exp -> QCHAR
Rule 40    exp -> exp binop exp
Rule 41    binop -> MINUS
Rule 42    binop -> PLUS
Rule 43    binop -> TIMES
Rule 44    binop -> DIVIDE
Rule 45    binop -> EQUAL
Rule 46    binop -> NEQUAL
Rule 47    binop -> GREATER
Rule 48    binop -> LESS
Rule 49    unop -> MINUS
Rule 50    unop -> NOT
Rule 51    pars -> pars COMMA exp
Rule 52    pars -> exp
Rule 53    var -> NAME
Rule 54    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 29
CHAR                 : 16
COMMA                : 7 51
DIVIDE               : 44
ELSE                 : 28
EQUAL                : 45
GREATER              : 47
IF                   : 27 28
INT                  : 15
KEYWORD              : 
LBRACE               : 10 11
LBRACK               : 17 31
LENGTH               : 33
LESS                 : 48
LPAR                 : 5 6 24 25 26 27 28 35 36 37
MINUS                : 41 49
NAME                 : 5 6 9 14 24 25 36 37 53
NEQUAL               : 46
NOT                  : 50
NUMBER               : 38
PLUS                 : 42
QCHAR                : 39
RBRACE               : 10 11
RBRACK               : 17 31
READ                 : 23
RETURN               : 21
RPAR                 : 5 6 24 25 26 27 28 35 36 37
SEMICOLON            : 14 18
TIMES                : 43
WHILE                : 26
WRITE                : 22
error                : 

Nonterminals, with rules where they appear

binop                : 40
block                : 5 6 20
declaration          : 1 2
empty                : 13
exp                  : 17 21 22 26 27 28 29 31 34 35 40 40 51 52
formal_par           : 7 8
formal_pars          : 5 7
fun_declaration      : 3
lexp                 : 23 29 31 32 33
pars                 : 25 37 51
program              : 1 0
statement            : 18 19 26 27 28 28
statements           : 10 18
type                 : 5 6 9 14 17
unop                 : 34
var                  : 30
var_declaration      : 4 12
var_declarations     : 10 11 12

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration program
    (2) program -> . declaration
    (3) declaration -> . fun_declaration
    (4) declaration -> . var_declaration
    (5) fun_declaration -> . type NAME LPAR formal_pars RPAR block
    (6) fun_declaration -> . type NAME LPAR RPAR block
    (14) var_declaration -> . type NAME SEMICOLON
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    INT             shift and go to state 2
    CHAR            shift and go to state 3

    var_declaration                shift and go to state 1
    fun_declaration                shift and go to state 4
    program                        shift and go to state 5
    declaration                    shift and go to state 6
    type                           shift and go to state 7

state 1

    (4) declaration -> var_declaration .

    INT             reduce using rule 4 (declaration -> var_declaration .)
    CHAR            reduce using rule 4 (declaration -> var_declaration .)
    $end            reduce using rule 4 (declaration -> var_declaration .)


state 2

    (15) type -> INT .

    NAME            reduce using rule 15 (type -> INT .)
    LBRACK          reduce using rule 15 (type -> INT .)


state 3

    (16) type -> CHAR .

    NAME            reduce using rule 16 (type -> CHAR .)
    LBRACK          reduce using rule 16 (type -> CHAR .)


state 4

    (3) declaration -> fun_declaration .

    INT             reduce using rule 3 (declaration -> fun_declaration .)
    CHAR            reduce using rule 3 (declaration -> fun_declaration .)
    $end            reduce using rule 3 (declaration -> fun_declaration .)


state 5

    (0) S' -> program .



state 6

    (1) program -> declaration . program
    (2) program -> declaration .
    (1) program -> . declaration program
    (2) program -> . declaration
    (3) declaration -> . fun_declaration
    (4) declaration -> . var_declaration
    (5) fun_declaration -> . type NAME LPAR formal_pars RPAR block
    (6) fun_declaration -> . type NAME LPAR RPAR block
    (14) var_declaration -> . type NAME SEMICOLON
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    $end            reduce using rule 2 (program -> declaration .)
    INT             shift and go to state 2
    CHAR            shift and go to state 3

    var_declaration                shift and go to state 1
    fun_declaration                shift and go to state 4
    program                        shift and go to state 8
    declaration                    shift and go to state 6
    type                           shift and go to state 7

state 7

    (5) fun_declaration -> type . NAME LPAR formal_pars RPAR block
    (6) fun_declaration -> type . NAME LPAR RPAR block
    (14) var_declaration -> type . NAME SEMICOLON
    (17) type -> type . LBRACK exp RBRACK

    NAME            shift and go to state 9
    LBRACK          shift and go to state 10


state 8

    (1) program -> declaration program .

    $end            reduce using rule 1 (program -> declaration program .)


state 9

    (5) fun_declaration -> type NAME . LPAR formal_pars RPAR block
    (6) fun_declaration -> type NAME . LPAR RPAR block
    (14) var_declaration -> type NAME . SEMICOLON

    LPAR            shift and go to state 11
    SEMICOLON       shift and go to state 12


state 10

    (17) type -> type LBRACK . exp RBRACK
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 20
    var                            shift and go to state 21

state 11

    (5) fun_declaration -> type NAME LPAR . formal_pars RPAR block
    (6) fun_declaration -> type NAME LPAR . RPAR block
    (7) formal_pars -> . formal_pars COMMA formal_par
    (8) formal_pars -> . formal_par
    (9) formal_par -> . type NAME
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    RPAR            shift and go to state 24
    INT             shift and go to state 2
    CHAR            shift and go to state 3

    formal_par                     shift and go to state 25
    type                           shift and go to state 27
    formal_pars                    shift and go to state 26

state 12

    (14) var_declaration -> type NAME SEMICOLON .

    INT             reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    CHAR            reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    $end            reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    RBRACE          reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    RETURN          reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    WRITE           reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    READ            reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    NAME            reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    WHILE           reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    IF              reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    LBRACE          reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)


state 13

    (34) exp -> unop . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 28
    var                            shift and go to state 21

state 14

    (35) exp -> LPAR . exp RPAR
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 29
    var                            shift and go to state 21

state 15

    (32) exp -> lexp .
    (31) lexp -> lexp . LBRACK exp RBRACK

    RPAR            reduce using rule 32 (exp -> lexp .)
    MINUS           reduce using rule 32 (exp -> lexp .)
    PLUS            reduce using rule 32 (exp -> lexp .)
    TIMES           reduce using rule 32 (exp -> lexp .)
    DIVIDE          reduce using rule 32 (exp -> lexp .)
    EQUAL           reduce using rule 32 (exp -> lexp .)
    NEQUAL          reduce using rule 32 (exp -> lexp .)
    GREATER         reduce using rule 32 (exp -> lexp .)
    LESS            reduce using rule 32 (exp -> lexp .)
    RBRACK          reduce using rule 32 (exp -> lexp .)
    COMMA           reduce using rule 32 (exp -> lexp .)
    RBRACE          reduce using rule 32 (exp -> lexp .)
    SEMICOLON       reduce using rule 32 (exp -> lexp .)
    ELSE            reduce using rule 32 (exp -> lexp .)
    LBRACK          shift and go to state 30


state 16

    (38) exp -> NUMBER .

    RPAR            reduce using rule 38 (exp -> NUMBER .)
    MINUS           reduce using rule 38 (exp -> NUMBER .)
    PLUS            reduce using rule 38 (exp -> NUMBER .)
    TIMES           reduce using rule 38 (exp -> NUMBER .)
    DIVIDE          reduce using rule 38 (exp -> NUMBER .)
    EQUAL           reduce using rule 38 (exp -> NUMBER .)
    NEQUAL          reduce using rule 38 (exp -> NUMBER .)
    GREATER         reduce using rule 38 (exp -> NUMBER .)
    LESS            reduce using rule 38 (exp -> NUMBER .)
    RBRACK          reduce using rule 38 (exp -> NUMBER .)
    COMMA           reduce using rule 38 (exp -> NUMBER .)
    RBRACE          reduce using rule 38 (exp -> NUMBER .)
    SEMICOLON       reduce using rule 38 (exp -> NUMBER .)
    ELSE            reduce using rule 38 (exp -> NUMBER .)


state 17

    (39) exp -> QCHAR .

    RPAR            reduce using rule 39 (exp -> QCHAR .)
    MINUS           reduce using rule 39 (exp -> QCHAR .)
    PLUS            reduce using rule 39 (exp -> QCHAR .)
    TIMES           reduce using rule 39 (exp -> QCHAR .)
    DIVIDE          reduce using rule 39 (exp -> QCHAR .)
    EQUAL           reduce using rule 39 (exp -> QCHAR .)
    NEQUAL          reduce using rule 39 (exp -> QCHAR .)
    GREATER         reduce using rule 39 (exp -> QCHAR .)
    LESS            reduce using rule 39 (exp -> QCHAR .)
    RBRACK          reduce using rule 39 (exp -> QCHAR .)
    COMMA           reduce using rule 39 (exp -> QCHAR .)
    RBRACE          reduce using rule 39 (exp -> QCHAR .)
    SEMICOLON       reduce using rule 39 (exp -> QCHAR .)
    ELSE            reduce using rule 39 (exp -> QCHAR .)


state 18

    (50) unop -> NOT .

    LENGTH          reduce using rule 50 (unop -> NOT .)
    LPAR            reduce using rule 50 (unop -> NOT .)
    NAME            reduce using rule 50 (unop -> NOT .)
    NUMBER          reduce using rule 50 (unop -> NOT .)
    QCHAR           reduce using rule 50 (unop -> NOT .)
    MINUS           reduce using rule 50 (unop -> NOT .)
    NOT             reduce using rule 50 (unop -> NOT .)


state 19

    (33) exp -> LENGTH . lexp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (53) var -> . NAME

    NAME            shift and go to state 32

    var                            shift and go to state 21
    lexp                           shift and go to state 31

state 20

    (17) type -> type LBRACK exp . RBRACK
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RBRACK          shift and go to state 36
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 21

    (30) lexp -> var .

    LBRACK          reduce using rule 30 (lexp -> var .)
    RBRACK          reduce using rule 30 (lexp -> var .)
    MINUS           reduce using rule 30 (lexp -> var .)
    PLUS            reduce using rule 30 (lexp -> var .)
    TIMES           reduce using rule 30 (lexp -> var .)
    DIVIDE          reduce using rule 30 (lexp -> var .)
    EQUAL           reduce using rule 30 (lexp -> var .)
    NEQUAL          reduce using rule 30 (lexp -> var .)
    GREATER         reduce using rule 30 (lexp -> var .)
    LESS            reduce using rule 30 (lexp -> var .)
    RPAR            reduce using rule 30 (lexp -> var .)
    COMMA           reduce using rule 30 (lexp -> var .)
    RBRACE          reduce using rule 30 (lexp -> var .)
    SEMICOLON       reduce using rule 30 (lexp -> var .)
    ELSE            reduce using rule 30 (lexp -> var .)
    ASSIGN          reduce using rule 30 (lexp -> var .)


state 22

    (49) unop -> MINUS .

    LENGTH          reduce using rule 49 (unop -> MINUS .)
    LPAR            reduce using rule 49 (unop -> MINUS .)
    NAME            reduce using rule 49 (unop -> MINUS .)
    NUMBER          reduce using rule 49 (unop -> MINUS .)
    QCHAR           reduce using rule 49 (unop -> MINUS .)
    MINUS           reduce using rule 49 (unop -> MINUS .)
    NOT             reduce using rule 49 (unop -> MINUS .)


state 23

    (36) exp -> NAME . LPAR RPAR
    (37) exp -> NAME . LPAR pars RPAR
    (53) var -> NAME .

    LPAR            shift and go to state 43
    LBRACK          reduce using rule 53 (var -> NAME .)
    MINUS           reduce using rule 53 (var -> NAME .)
    PLUS            reduce using rule 53 (var -> NAME .)
    TIMES           reduce using rule 53 (var -> NAME .)
    DIVIDE          reduce using rule 53 (var -> NAME .)
    EQUAL           reduce using rule 53 (var -> NAME .)
    NEQUAL          reduce using rule 53 (var -> NAME .)
    GREATER         reduce using rule 53 (var -> NAME .)
    LESS            reduce using rule 53 (var -> NAME .)
    RPAR            reduce using rule 53 (var -> NAME .)
    COMMA           reduce using rule 53 (var -> NAME .)
    RBRACK          reduce using rule 53 (var -> NAME .)
    RBRACE          reduce using rule 53 (var -> NAME .)
    SEMICOLON       reduce using rule 53 (var -> NAME .)
    ELSE            reduce using rule 53 (var -> NAME .)


state 24

    (6) fun_declaration -> type NAME LPAR RPAR . block
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE

    LBRACE          shift and go to state 44

    block                          shift and go to state 45

state 25

    (8) formal_pars -> formal_par .

    RPAR            reduce using rule 8 (formal_pars -> formal_par .)
    COMMA           reduce using rule 8 (formal_pars -> formal_par .)


state 26

    (5) fun_declaration -> type NAME LPAR formal_pars . RPAR block
    (7) formal_pars -> formal_pars . COMMA formal_par

    RPAR            shift and go to state 46
    COMMA           shift and go to state 47


state 27

    (9) formal_par -> type . NAME
    (17) type -> type . LBRACK exp RBRACK

    NAME            shift and go to state 48
    LBRACK          shift and go to state 10


state 28

    (34) exp -> unop exp .
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
    RPAR            reduce using rule 34 (exp -> unop exp .)
    RBRACK          reduce using rule 34 (exp -> unop exp .)
    COMMA           reduce using rule 34 (exp -> unop exp .)
    RBRACE          reduce using rule 34 (exp -> unop exp .)
    SEMICOLON       reduce using rule 34 (exp -> unop exp .)
    ELSE            reduce using rule 34 (exp -> unop exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

  ! MINUS           [ reduce using rule 34 (exp -> unop exp .) ]
  ! PLUS            [ reduce using rule 34 (exp -> unop exp .) ]
  ! TIMES           [ reduce using rule 34 (exp -> unop exp .) ]
  ! DIVIDE          [ reduce using rule 34 (exp -> unop exp .) ]
  ! EQUAL           [ reduce using rule 34 (exp -> unop exp .) ]
  ! NEQUAL          [ reduce using rule 34 (exp -> unop exp .) ]
  ! GREATER         [ reduce using rule 34 (exp -> unop exp .) ]
  ! LESS            [ reduce using rule 34 (exp -> unop exp .) ]

    binop                          shift and go to state 34

state 29

    (35) exp -> LPAR exp . RPAR
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RPAR            shift and go to state 49
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 30

    (31) lexp -> lexp LBRACK . exp RBRACK
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 50
    var                            shift and go to state 21

state 31

    (33) exp -> LENGTH lexp .
    (31) lexp -> lexp . LBRACK exp RBRACK

    RPAR            reduce using rule 33 (exp -> LENGTH lexp .)
    MINUS           reduce using rule 33 (exp -> LENGTH lexp .)
    PLUS            reduce using rule 33 (exp -> LENGTH lexp .)
    TIMES           reduce using rule 33 (exp -> LENGTH lexp .)
    DIVIDE          reduce using rule 33 (exp -> LENGTH lexp .)
    EQUAL           reduce using rule 33 (exp -> LENGTH lexp .)
    NEQUAL          reduce using rule 33 (exp -> LENGTH lexp .)
    GREATER         reduce using rule 33 (exp -> LENGTH lexp .)
    LESS            reduce using rule 33 (exp -> LENGTH lexp .)
    RBRACK          reduce using rule 33 (exp -> LENGTH lexp .)
    COMMA           reduce using rule 33 (exp -> LENGTH lexp .)
    RBRACE          reduce using rule 33 (exp -> LENGTH lexp .)
    SEMICOLON       reduce using rule 33 (exp -> LENGTH lexp .)
    ELSE            reduce using rule 33 (exp -> LENGTH lexp .)
    LBRACK          shift and go to state 30


state 32

    (53) var -> NAME .

    LBRACK          reduce using rule 53 (var -> NAME .)
    RBRACE          reduce using rule 53 (var -> NAME .)
    SEMICOLON       reduce using rule 53 (var -> NAME .)
    ELSE            reduce using rule 53 (var -> NAME .)
    RBRACK          reduce using rule 53 (var -> NAME .)
    MINUS           reduce using rule 53 (var -> NAME .)
    PLUS            reduce using rule 53 (var -> NAME .)
    TIMES           reduce using rule 53 (var -> NAME .)
    DIVIDE          reduce using rule 53 (var -> NAME .)
    EQUAL           reduce using rule 53 (var -> NAME .)
    NEQUAL          reduce using rule 53 (var -> NAME .)
    GREATER         reduce using rule 53 (var -> NAME .)
    LESS            reduce using rule 53 (var -> NAME .)
    RPAR            reduce using rule 53 (var -> NAME .)
    COMMA           reduce using rule 53 (var -> NAME .)


state 33

    (44) binop -> DIVIDE .

    LENGTH          reduce using rule 44 (binop -> DIVIDE .)
    LPAR            reduce using rule 44 (binop -> DIVIDE .)
    NAME            reduce using rule 44 (binop -> DIVIDE .)
    NUMBER          reduce using rule 44 (binop -> DIVIDE .)
    QCHAR           reduce using rule 44 (binop -> DIVIDE .)
    MINUS           reduce using rule 44 (binop -> DIVIDE .)
    NOT             reduce using rule 44 (binop -> DIVIDE .)


state 34

    (40) exp -> exp binop . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 51
    var                            shift and go to state 21

state 35

    (45) binop -> EQUAL .

    LENGTH          reduce using rule 45 (binop -> EQUAL .)
    LPAR            reduce using rule 45 (binop -> EQUAL .)
    NAME            reduce using rule 45 (binop -> EQUAL .)
    NUMBER          reduce using rule 45 (binop -> EQUAL .)
    QCHAR           reduce using rule 45 (binop -> EQUAL .)
    MINUS           reduce using rule 45 (binop -> EQUAL .)
    NOT             reduce using rule 45 (binop -> EQUAL .)


state 36

    (17) type -> type LBRACK exp RBRACK .

    NAME            reduce using rule 17 (type -> type LBRACK exp RBRACK .)
    LBRACK          reduce using rule 17 (type -> type LBRACK exp RBRACK .)


state 37

    (46) binop -> NEQUAL .

    LENGTH          reduce using rule 46 (binop -> NEQUAL .)
    LPAR            reduce using rule 46 (binop -> NEQUAL .)
    NAME            reduce using rule 46 (binop -> NEQUAL .)
    NUMBER          reduce using rule 46 (binop -> NEQUAL .)
    QCHAR           reduce using rule 46 (binop -> NEQUAL .)
    MINUS           reduce using rule 46 (binop -> NEQUAL .)
    NOT             reduce using rule 46 (binop -> NEQUAL .)


state 38

    (43) binop -> TIMES .

    LENGTH          reduce using rule 43 (binop -> TIMES .)
    LPAR            reduce using rule 43 (binop -> TIMES .)
    NAME            reduce using rule 43 (binop -> TIMES .)
    NUMBER          reduce using rule 43 (binop -> TIMES .)
    QCHAR           reduce using rule 43 (binop -> TIMES .)
    MINUS           reduce using rule 43 (binop -> TIMES .)
    NOT             reduce using rule 43 (binop -> TIMES .)


state 39

    (42) binop -> PLUS .

    LENGTH          reduce using rule 42 (binop -> PLUS .)
    LPAR            reduce using rule 42 (binop -> PLUS .)
    NAME            reduce using rule 42 (binop -> PLUS .)
    NUMBER          reduce using rule 42 (binop -> PLUS .)
    QCHAR           reduce using rule 42 (binop -> PLUS .)
    MINUS           reduce using rule 42 (binop -> PLUS .)
    NOT             reduce using rule 42 (binop -> PLUS .)


state 40

    (48) binop -> LESS .

    LENGTH          reduce using rule 48 (binop -> LESS .)
    LPAR            reduce using rule 48 (binop -> LESS .)
    NAME            reduce using rule 48 (binop -> LESS .)
    NUMBER          reduce using rule 48 (binop -> LESS .)
    QCHAR           reduce using rule 48 (binop -> LESS .)
    MINUS           reduce using rule 48 (binop -> LESS .)
    NOT             reduce using rule 48 (binop -> LESS .)


state 41

    (41) binop -> MINUS .

    LENGTH          reduce using rule 41 (binop -> MINUS .)
    LPAR            reduce using rule 41 (binop -> MINUS .)
    NAME            reduce using rule 41 (binop -> MINUS .)
    NUMBER          reduce using rule 41 (binop -> MINUS .)
    QCHAR           reduce using rule 41 (binop -> MINUS .)
    MINUS           reduce using rule 41 (binop -> MINUS .)
    NOT             reduce using rule 41 (binop -> MINUS .)


state 42

    (47) binop -> GREATER .

    LENGTH          reduce using rule 47 (binop -> GREATER .)
    LPAR            reduce using rule 47 (binop -> GREATER .)
    NAME            reduce using rule 47 (binop -> GREATER .)
    NUMBER          reduce using rule 47 (binop -> GREATER .)
    QCHAR           reduce using rule 47 (binop -> GREATER .)
    MINUS           reduce using rule 47 (binop -> GREATER .)
    NOT             reduce using rule 47 (binop -> GREATER .)


state 43

    (36) exp -> NAME LPAR . RPAR
    (37) exp -> NAME LPAR . pars RPAR
    (51) pars -> . pars COMMA exp
    (52) pars -> . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    RPAR            shift and go to state 52
    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    pars                           shift and go to state 54
    exp                            shift and go to state 53
    var                            shift and go to state 21

state 44

    (10) block -> LBRACE . var_declarations statements RBRACE
    (11) block -> LBRACE . var_declarations RBRACE
    (12) var_declarations -> . var_declaration var_declarations
    (13) var_declarations -> . empty
    (14) var_declaration -> . type NAME SEMICOLON
    (54) empty -> .
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    RBRACE          reduce using rule 54 (empty -> .)
    RETURN          reduce using rule 54 (empty -> .)
    WRITE           reduce using rule 54 (empty -> .)
    READ            reduce using rule 54 (empty -> .)
    NAME            reduce using rule 54 (empty -> .)
    WHILE           reduce using rule 54 (empty -> .)
    IF              reduce using rule 54 (empty -> .)
    LBRACE          reduce using rule 54 (empty -> .)
    INT             shift and go to state 2
    CHAR            shift and go to state 3

    var_declaration                shift and go to state 55
    var_declarations               shift and go to state 56
    type                           shift and go to state 57
    empty                          shift and go to state 58

state 45

    (6) fun_declaration -> type NAME LPAR RPAR block .

    INT             reduce using rule 6 (fun_declaration -> type NAME LPAR RPAR block .)
    CHAR            reduce using rule 6 (fun_declaration -> type NAME LPAR RPAR block .)
    $end            reduce using rule 6 (fun_declaration -> type NAME LPAR RPAR block .)


state 46

    (5) fun_declaration -> type NAME LPAR formal_pars RPAR . block
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE

    LBRACE          shift and go to state 44

    block                          shift and go to state 59

state 47

    (7) formal_pars -> formal_pars COMMA . formal_par
    (9) formal_par -> . type NAME
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    INT             shift and go to state 2
    CHAR            shift and go to state 3

    formal_par                     shift and go to state 60
    type                           shift and go to state 27

state 48

    (9) formal_par -> type NAME .

    RPAR            reduce using rule 9 (formal_par -> type NAME .)
    COMMA           reduce using rule 9 (formal_par -> type NAME .)


state 49

    (35) exp -> LPAR exp RPAR .

    RPAR            reduce using rule 35 (exp -> LPAR exp RPAR .)
    MINUS           reduce using rule 35 (exp -> LPAR exp RPAR .)
    PLUS            reduce using rule 35 (exp -> LPAR exp RPAR .)
    TIMES           reduce using rule 35 (exp -> LPAR exp RPAR .)
    DIVIDE          reduce using rule 35 (exp -> LPAR exp RPAR .)
    EQUAL           reduce using rule 35 (exp -> LPAR exp RPAR .)
    NEQUAL          reduce using rule 35 (exp -> LPAR exp RPAR .)
    GREATER         reduce using rule 35 (exp -> LPAR exp RPAR .)
    LESS            reduce using rule 35 (exp -> LPAR exp RPAR .)
    RBRACK          reduce using rule 35 (exp -> LPAR exp RPAR .)
    COMMA           reduce using rule 35 (exp -> LPAR exp RPAR .)
    RBRACE          reduce using rule 35 (exp -> LPAR exp RPAR .)
    SEMICOLON       reduce using rule 35 (exp -> LPAR exp RPAR .)
    ELSE            reduce using rule 35 (exp -> LPAR exp RPAR .)


state 50

    (31) lexp -> lexp LBRACK exp . RBRACK
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RBRACK          shift and go to state 61
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 51

    (40) exp -> exp binop exp .
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
    RPAR            reduce using rule 40 (exp -> exp binop exp .)
    RBRACK          reduce using rule 40 (exp -> exp binop exp .)
    COMMA           reduce using rule 40 (exp -> exp binop exp .)
    RBRACE          reduce using rule 40 (exp -> exp binop exp .)
    SEMICOLON       reduce using rule 40 (exp -> exp binop exp .)
    ELSE            reduce using rule 40 (exp -> exp binop exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

  ! MINUS           [ reduce using rule 40 (exp -> exp binop exp .) ]
  ! PLUS            [ reduce using rule 40 (exp -> exp binop exp .) ]
  ! TIMES           [ reduce using rule 40 (exp -> exp binop exp .) ]
  ! DIVIDE          [ reduce using rule 40 (exp -> exp binop exp .) ]
  ! EQUAL           [ reduce using rule 40 (exp -> exp binop exp .) ]
  ! NEQUAL          [ reduce using rule 40 (exp -> exp binop exp .) ]
  ! GREATER         [ reduce using rule 40 (exp -> exp binop exp .) ]
  ! LESS            [ reduce using rule 40 (exp -> exp binop exp .) ]

    binop                          shift and go to state 34

state 52

    (36) exp -> NAME LPAR RPAR .

    RPAR            reduce using rule 36 (exp -> NAME LPAR RPAR .)
    MINUS           reduce using rule 36 (exp -> NAME LPAR RPAR .)
    PLUS            reduce using rule 36 (exp -> NAME LPAR RPAR .)
    TIMES           reduce using rule 36 (exp -> NAME LPAR RPAR .)
    DIVIDE          reduce using rule 36 (exp -> NAME LPAR RPAR .)
    EQUAL           reduce using rule 36 (exp -> NAME LPAR RPAR .)
    NEQUAL          reduce using rule 36 (exp -> NAME LPAR RPAR .)
    GREATER         reduce using rule 36 (exp -> NAME LPAR RPAR .)
    LESS            reduce using rule 36 (exp -> NAME LPAR RPAR .)
    RBRACK          reduce using rule 36 (exp -> NAME LPAR RPAR .)
    COMMA           reduce using rule 36 (exp -> NAME LPAR RPAR .)
    RBRACE          reduce using rule 36 (exp -> NAME LPAR RPAR .)
    SEMICOLON       reduce using rule 36 (exp -> NAME LPAR RPAR .)
    ELSE            reduce using rule 36 (exp -> NAME LPAR RPAR .)


state 53

    (52) pars -> exp .
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RPAR            reduce using rule 52 (pars -> exp .)
    COMMA           reduce using rule 52 (pars -> exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 54

    (37) exp -> NAME LPAR pars . RPAR
    (51) pars -> pars . COMMA exp

    RPAR            shift and go to state 62
    COMMA           shift and go to state 63


state 55

    (12) var_declarations -> var_declaration . var_declarations
    (12) var_declarations -> . var_declaration var_declarations
    (13) var_declarations -> . empty
    (14) var_declaration -> . type NAME SEMICOLON
    (54) empty -> .
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    RBRACE          reduce using rule 54 (empty -> .)
    RETURN          reduce using rule 54 (empty -> .)
    WRITE           reduce using rule 54 (empty -> .)
    READ            reduce using rule 54 (empty -> .)
    NAME            reduce using rule 54 (empty -> .)
    WHILE           reduce using rule 54 (empty -> .)
    IF              reduce using rule 54 (empty -> .)
    LBRACE          reduce using rule 54 (empty -> .)
    INT             shift and go to state 2
    CHAR            shift and go to state 3

    var_declaration                shift and go to state 55
    type                           shift and go to state 57
    empty                          shift and go to state 58
    var_declarations               shift and go to state 64

state 56

    (10) block -> LBRACE var_declarations . statements RBRACE
    (11) block -> LBRACE var_declarations . RBRACE
    (18) statements -> . statements SEMICOLON statement
    (19) statements -> . statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (53) var -> . NAME

    RBRACE          shift and go to state 71
    RETURN          shift and go to state 65
    WRITE           shift and go to state 72
    READ            shift and go to state 66
    NAME            shift and go to state 74
    WHILE           shift and go to state 67
    IF              shift and go to state 73
    LBRACE          shift and go to state 44

    statements                     shift and go to state 68
    statement                      shift and go to state 70
    var                            shift and go to state 21
    block                          shift and go to state 75
    lexp                           shift and go to state 69

state 57

    (14) var_declaration -> type . NAME SEMICOLON
    (17) type -> type . LBRACK exp RBRACK

    NAME            shift and go to state 76
    LBRACK          shift and go to state 10


state 58

    (13) var_declarations -> empty .

    RBRACE          reduce using rule 13 (var_declarations -> empty .)
    RETURN          reduce using rule 13 (var_declarations -> empty .)
    WRITE           reduce using rule 13 (var_declarations -> empty .)
    READ            reduce using rule 13 (var_declarations -> empty .)
    NAME            reduce using rule 13 (var_declarations -> empty .)
    WHILE           reduce using rule 13 (var_declarations -> empty .)
    IF              reduce using rule 13 (var_declarations -> empty .)
    LBRACE          reduce using rule 13 (var_declarations -> empty .)


state 59

    (5) fun_declaration -> type NAME LPAR formal_pars RPAR block .

    INT             reduce using rule 5 (fun_declaration -> type NAME LPAR formal_pars RPAR block .)
    CHAR            reduce using rule 5 (fun_declaration -> type NAME LPAR formal_pars RPAR block .)
    $end            reduce using rule 5 (fun_declaration -> type NAME LPAR formal_pars RPAR block .)


state 60

    (7) formal_pars -> formal_pars COMMA formal_par .

    RPAR            reduce using rule 7 (formal_pars -> formal_pars COMMA formal_par .)
    COMMA           reduce using rule 7 (formal_pars -> formal_pars COMMA formal_par .)


state 61

    (31) lexp -> lexp LBRACK exp RBRACK .

    LBRACK          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    RBRACK          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    MINUS           reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    PLUS            reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    TIMES           reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    DIVIDE          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    EQUAL           reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    NEQUAL          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    GREATER         reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    LESS            reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    RPAR            reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    COMMA           reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    RBRACE          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    SEMICOLON       reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    ELSE            reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    ASSIGN          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)


state 62

    (37) exp -> NAME LPAR pars RPAR .

    RPAR            reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    MINUS           reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    PLUS            reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    TIMES           reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    DIVIDE          reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    EQUAL           reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    NEQUAL          reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    GREATER         reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    LESS            reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    RBRACK          reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    COMMA           reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    RBRACE          reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    SEMICOLON       reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    ELSE            reduce using rule 37 (exp -> NAME LPAR pars RPAR .)


state 63

    (51) pars -> pars COMMA . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 77
    var                            shift and go to state 21

state 64

    (12) var_declarations -> var_declaration var_declarations .

    RBRACE          reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    RETURN          reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    WRITE           reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    READ            reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    NAME            reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    WHILE           reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    IF              reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    LBRACE          reduce using rule 12 (var_declarations -> var_declaration var_declarations .)


state 65

    (21) statement -> RETURN . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 78
    var                            shift and go to state 21

state 66

    (23) statement -> READ . lexp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (53) var -> . NAME

    NAME            shift and go to state 32

    var                            shift and go to state 21
    lexp                           shift and go to state 79

state 67

    (26) statement -> WHILE . LPAR exp RPAR statement

    LPAR            shift and go to state 80


state 68

    (10) block -> LBRACE var_declarations statements . RBRACE
    (18) statements -> statements . SEMICOLON statement

    RBRACE          shift and go to state 81
    SEMICOLON       shift and go to state 82


state 69

    (29) statement -> lexp . ASSIGN exp
    (31) lexp -> lexp . LBRACK exp RBRACK

    ASSIGN          shift and go to state 83
    LBRACK          shift and go to state 30


state 70

    (19) statements -> statement .

    RBRACE          reduce using rule 19 (statements -> statement .)
    SEMICOLON       reduce using rule 19 (statements -> statement .)


state 71

    (11) block -> LBRACE var_declarations RBRACE .

    RBRACE          reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    SEMICOLON       reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    ELSE            reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    INT             reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    CHAR            reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    $end            reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)


state 72

    (22) statement -> WRITE . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 84
    var                            shift and go to state 21

state 73

    (27) statement -> IF . LPAR exp RPAR statement
    (28) statement -> IF . LPAR exp RPAR statement ELSE statement

    LPAR            shift and go to state 85


state 74

    (24) statement -> NAME . LPAR RPAR
    (25) statement -> NAME . LPAR pars RPAR
    (53) var -> NAME .

    LPAR            shift and go to state 86
    ASSIGN          reduce using rule 53 (var -> NAME .)
    LBRACK          reduce using rule 53 (var -> NAME .)


state 75

    (20) statement -> block .

    RBRACE          reduce using rule 20 (statement -> block .)
    SEMICOLON       reduce using rule 20 (statement -> block .)
    ELSE            reduce using rule 20 (statement -> block .)


state 76

    (14) var_declaration -> type NAME . SEMICOLON

    SEMICOLON       shift and go to state 12


state 77

    (51) pars -> pars COMMA exp .
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RPAR            reduce using rule 51 (pars -> pars COMMA exp .)
    COMMA           reduce using rule 51 (pars -> pars COMMA exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 78

    (21) statement -> RETURN exp .
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RBRACE          reduce using rule 21 (statement -> RETURN exp .)
    SEMICOLON       reduce using rule 21 (statement -> RETURN exp .)
    ELSE            reduce using rule 21 (statement -> RETURN exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 79

    (23) statement -> READ lexp .
    (31) lexp -> lexp . LBRACK exp RBRACK

    RBRACE          reduce using rule 23 (statement -> READ lexp .)
    SEMICOLON       reduce using rule 23 (statement -> READ lexp .)
    ELSE            reduce using rule 23 (statement -> READ lexp .)
    LBRACK          shift and go to state 30


state 80

    (26) statement -> WHILE LPAR . exp RPAR statement
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    exp                            shift and go to state 87
    var                            shift and go to state 21
    lexp                           shift and go to state 15

state 81

    (10) block -> LBRACE var_declarations statements RBRACE .

    RBRACE          reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    SEMICOLON       reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    ELSE            reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    INT             reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    CHAR            reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    $end            reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)


state 82

    (18) statements -> statements SEMICOLON . statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (53) var -> . NAME

    RETURN          shift and go to state 65
    WRITE           shift and go to state 72
    READ            shift and go to state 66
    NAME            shift and go to state 74
    WHILE           shift and go to state 67
    IF              shift and go to state 73
    LBRACE          shift and go to state 44

    statement                      shift and go to state 88
    var                            shift and go to state 21
    block                          shift and go to state 75
    lexp                           shift and go to state 69

state 83

    (29) statement -> lexp ASSIGN . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    exp                            shift and go to state 89
    var                            shift and go to state 21

state 84

    (22) statement -> WRITE exp .
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RBRACE          reduce using rule 22 (statement -> WRITE exp .)
    SEMICOLON       reduce using rule 22 (statement -> WRITE exp .)
    ELSE            reduce using rule 22 (statement -> WRITE exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 85

    (27) statement -> IF LPAR . exp RPAR statement
    (28) statement -> IF LPAR . exp RPAR statement ELSE statement
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    exp                            shift and go to state 90
    var                            shift and go to state 21
    lexp                           shift and go to state 15

state 86

    (24) statement -> NAME LPAR . RPAR
    (25) statement -> NAME LPAR . pars RPAR
    (51) pars -> . pars COMMA exp
    (52) pars -> . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp binop exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (49) unop -> . MINUS
    (50) unop -> . NOT
    (53) var -> . NAME

    RPAR            shift and go to state 91
    LENGTH          shift and go to state 19
    LPAR            shift and go to state 14
    NAME            shift and go to state 23
    NUMBER          shift and go to state 16
    QCHAR           shift and go to state 17
    MINUS           shift and go to state 22
    NOT             shift and go to state 18

    unop                           shift and go to state 13
    lexp                           shift and go to state 15
    pars                           shift and go to state 92
    exp                            shift and go to state 53
    var                            shift and go to state 21

state 87

    (26) statement -> WHILE LPAR exp . RPAR statement
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RPAR            shift and go to state 93
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 88

    (18) statements -> statements SEMICOLON statement .

    RBRACE          reduce using rule 18 (statements -> statements SEMICOLON statement .)
    SEMICOLON       reduce using rule 18 (statements -> statements SEMICOLON statement .)


state 89

    (29) statement -> lexp ASSIGN exp .
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RBRACE          reduce using rule 29 (statement -> lexp ASSIGN exp .)
    SEMICOLON       reduce using rule 29 (statement -> lexp ASSIGN exp .)
    ELSE            reduce using rule 29 (statement -> lexp ASSIGN exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 90

    (27) statement -> IF LPAR exp . RPAR statement
    (28) statement -> IF LPAR exp . RPAR statement ELSE statement
    (40) exp -> exp . binop exp
    (41) binop -> . MINUS
    (42) binop -> . PLUS
    (43) binop -> . TIMES
    (44) binop -> . DIVIDE
    (45) binop -> . EQUAL
    (46) binop -> . NEQUAL
    (47) binop -> . GREATER
    (48) binop -> . LESS

    RPAR            shift and go to state 94
    MINUS           shift and go to state 41
    PLUS            shift and go to state 39
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 33
    EQUAL           shift and go to state 35
    NEQUAL          shift and go to state 37
    GREATER         shift and go to state 42
    LESS            shift and go to state 40

    binop                          shift and go to state 34

state 91

    (24) statement -> NAME LPAR RPAR .

    RBRACE          reduce using rule 24 (statement -> NAME LPAR RPAR .)
    SEMICOLON       reduce using rule 24 (statement -> NAME LPAR RPAR .)
    ELSE            reduce using rule 24 (statement -> NAME LPAR RPAR .)


state 92

    (25) statement -> NAME LPAR pars . RPAR
    (51) pars -> pars . COMMA exp

    RPAR            shift and go to state 95
    COMMA           shift and go to state 63


state 93

    (26) statement -> WHILE LPAR exp RPAR . statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (53) var -> . NAME

    RETURN          shift and go to state 65
    WRITE           shift and go to state 72
    READ            shift and go to state 66
    NAME            shift and go to state 74
    WHILE           shift and go to state 67
    IF              shift and go to state 73
    LBRACE          shift and go to state 44

    statement                      shift and go to state 96
    var                            shift and go to state 21
    block                          shift and go to state 75
    lexp                           shift and go to state 69

state 94

    (27) statement -> IF LPAR exp RPAR . statement
    (28) statement -> IF LPAR exp RPAR . statement ELSE statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (53) var -> . NAME

    RETURN          shift and go to state 65
    WRITE           shift and go to state 72
    READ            shift and go to state 66
    NAME            shift and go to state 74
    WHILE           shift and go to state 67
    IF              shift and go to state 73
    LBRACE          shift and go to state 44

    statement                      shift and go to state 97
    var                            shift and go to state 21
    block                          shift and go to state 75
    lexp                           shift and go to state 69

state 95

    (25) statement -> NAME LPAR pars RPAR .

    RBRACE          reduce using rule 25 (statement -> NAME LPAR pars RPAR .)
    SEMICOLON       reduce using rule 25 (statement -> NAME LPAR pars RPAR .)
    ELSE            reduce using rule 25 (statement -> NAME LPAR pars RPAR .)


state 96

    (26) statement -> WHILE LPAR exp RPAR statement .

    RBRACE          reduce using rule 26 (statement -> WHILE LPAR exp RPAR statement .)
    SEMICOLON       reduce using rule 26 (statement -> WHILE LPAR exp RPAR statement .)
    ELSE            reduce using rule 26 (statement -> WHILE LPAR exp RPAR statement .)


state 97

    (27) statement -> IF LPAR exp RPAR statement .
    (28) statement -> IF LPAR exp RPAR statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    RBRACE          reduce using rule 27 (statement -> IF LPAR exp RPAR statement .)
    SEMICOLON       reduce using rule 27 (statement -> IF LPAR exp RPAR statement .)
    ELSE            shift and go to state 98

  ! ELSE            [ reduce using rule 27 (statement -> IF LPAR exp RPAR statement .) ]


state 98

    (28) statement -> IF LPAR exp RPAR statement ELSE . statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (53) var -> . NAME

    RETURN          shift and go to state 65
    WRITE           shift and go to state 72
    READ            shift and go to state 66
    NAME            shift and go to state 74
    WHILE           shift and go to state 67
    IF              shift and go to state 73
    LBRACE          shift and go to state 44

    statement                      shift and go to state 99
    var                            shift and go to state 21
    block                          shift and go to state 75
    lexp                           shift and go to state 69

state 99

    (28) statement -> IF LPAR exp RPAR statement ELSE statement .

    RBRACE          reduce using rule 28 (statement -> IF LPAR exp RPAR statement ELSE statement .)
    SEMICOLON       reduce using rule 28 (statement -> IF LPAR exp RPAR statement ELSE statement .)
    ELSE            reduce using rule 28 (statement -> IF LPAR exp RPAR statement ELSE statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 28 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 28 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 28 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 28 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 28 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 28 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 28 resolved as shift
WARNING: shift/reduce conflict for LESS in state 28 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 51 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 51 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 51 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 51 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 51 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 51 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 51 resolved as shift
WARNING: shift/reduce conflict for LESS in state 51 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 97 resolved as shift
