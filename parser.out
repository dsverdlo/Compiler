Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    KEYWORD

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration program
Rule 2     program -> declaration
Rule 3     declaration -> fun_declaration
Rule 4     declaration -> var_declaration
Rule 5     fun_declaration -> type NAME LPAR formal_pars RPAR block
Rule 6     fun_declaration -> type NAME LPAR RPAR block
Rule 7     formal_pars -> formal_pars COMMA formal_par
Rule 8     formal_pars -> formal_par
Rule 9     formal_par -> type NAME
Rule 10    block -> LBRACE var_declarations statements RBRACE
Rule 11    block -> LBRACE var_declarations RBRACE
Rule 12    var_declarations -> var_declaration var_declarations
Rule 13    var_declarations -> empty
Rule 14    var_declaration -> type NAME SEMICOLON
Rule 15    type -> INT
Rule 16    type -> CHAR
Rule 17    type -> type LBRACK exp RBRACK
Rule 18    statements -> statements SEMICOLON statement
Rule 19    statements -> statement
Rule 20    statement -> block
Rule 21    statement -> RETURN exp
Rule 22    statement -> WRITE exp
Rule 23    statement -> READ lexp
Rule 24    statement -> NAME LPAR RPAR
Rule 25    statement -> NAME LPAR pars RPAR
Rule 26    statement -> WHILE LPAR exp RPAR statement
Rule 27    statement -> IF LPAR exp RPAR statement
Rule 28    statement -> IF LPAR exp RPAR statement ELSE statement
Rule 29    statement -> lexp ASSIGN exp
Rule 30    lexp -> var
Rule 31    lexp -> lexp LBRACK exp RBRACK
Rule 32    exp -> lexp
Rule 33    exp -> LENGTH lexp
Rule 34    exp -> unop exp
Rule 35    exp -> LPAR exp RPAR
Rule 36    exp -> NAME LPAR RPAR
Rule 37    exp -> NAME LPAR pars RPAR
Rule 38    exp -> NUMBER
Rule 39    exp -> QCHAR
Rule 40    exp -> exp MINUS exp
Rule 41    exp -> exp PLUS exp
Rule 42    exp -> exp TIMES exp
Rule 43    exp -> exp DIVIDE exp
Rule 44    exp -> exp EQUAL exp
Rule 45    exp -> exp NEQUAL exp
Rule 46    exp -> exp GREATER exp
Rule 47    exp -> exp LESS exp
Rule 48    unop -> MINUS
Rule 49    unop -> NOT
Rule 50    pars -> pars COMMA exp
Rule 51    pars -> exp
Rule 52    var -> NAME
Rule 53    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 29
CHAR                 : 16
COMMA                : 7 50
DIVIDE               : 43
ELSE                 : 28
EQUAL                : 44
GREATER              : 46
IF                   : 27 28
INT                  : 15
KEYWORD              : 
LBRACE               : 10 11
LBRACK               : 17 31
LENGTH               : 33
LESS                 : 47
LPAR                 : 5 6 24 25 26 27 28 35 36 37
MINUS                : 40 48
NAME                 : 5 6 9 14 24 25 36 37 52
NEQUAL               : 45
NOT                  : 49
NUMBER               : 38
PLUS                 : 41
QCHAR                : 39
RBRACE               : 10 11
RBRACK               : 17 31
READ                 : 23
RETURN               : 21
RPAR                 : 5 6 24 25 26 27 28 35 36 37
SEMICOLON            : 14 18
TIMES                : 42
WHILE                : 26
WRITE                : 22
error                : 

Nonterminals, with rules where they appear

block                : 5 6 20
declaration          : 1 2
empty                : 13
exp                  : 17 21 22 26 27 28 29 31 34 35 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 50 51
formal_par           : 7 8
formal_pars          : 5 7
fun_declaration      : 3
lexp                 : 23 29 31 32 33
pars                 : 25 37 50
program              : 1 0
statement            : 18 19 26 27 28 28
statements           : 10 18
type                 : 5 6 9 14 17
unop                 : 34
var                  : 30
var_declaration      : 4 12
var_declarations     : 10 11 12

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration program
    (2) program -> . declaration
    (3) declaration -> . fun_declaration
    (4) declaration -> . var_declaration
    (5) fun_declaration -> . type NAME LPAR formal_pars RPAR block
    (6) fun_declaration -> . type NAME LPAR RPAR block
    (14) var_declaration -> . type NAME SEMICOLON
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    INT             shift and go to state 2
    CHAR            shift and go to state 3

    var_declaration                shift and go to state 1
    fun_declaration                shift and go to state 4
    program                        shift and go to state 5
    declaration                    shift and go to state 6
    type                           shift and go to state 7

state 1

    (4) declaration -> var_declaration .

    INT             reduce using rule 4 (declaration -> var_declaration .)
    CHAR            reduce using rule 4 (declaration -> var_declaration .)
    $end            reduce using rule 4 (declaration -> var_declaration .)


state 2

    (15) type -> INT .

    NAME            reduce using rule 15 (type -> INT .)
    LBRACK          reduce using rule 15 (type -> INT .)


state 3

    (16) type -> CHAR .

    NAME            reduce using rule 16 (type -> CHAR .)
    LBRACK          reduce using rule 16 (type -> CHAR .)


state 4

    (3) declaration -> fun_declaration .

    INT             reduce using rule 3 (declaration -> fun_declaration .)
    CHAR            reduce using rule 3 (declaration -> fun_declaration .)
    $end            reduce using rule 3 (declaration -> fun_declaration .)


state 5

    (0) S' -> program .



state 6

    (1) program -> declaration . program
    (2) program -> declaration .
    (1) program -> . declaration program
    (2) program -> . declaration
    (3) declaration -> . fun_declaration
    (4) declaration -> . var_declaration
    (5) fun_declaration -> . type NAME LPAR formal_pars RPAR block
    (6) fun_declaration -> . type NAME LPAR RPAR block
    (14) var_declaration -> . type NAME SEMICOLON
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    $end            reduce using rule 2 (program -> declaration .)
    INT             shift and go to state 2
    CHAR            shift and go to state 3

    var_declaration                shift and go to state 1
    fun_declaration                shift and go to state 4
    program                        shift and go to state 8
    declaration                    shift and go to state 6
    type                           shift and go to state 7

state 7

    (5) fun_declaration -> type . NAME LPAR formal_pars RPAR block
    (6) fun_declaration -> type . NAME LPAR RPAR block
    (14) var_declaration -> type . NAME SEMICOLON
    (17) type -> type . LBRACK exp RBRACK

    NAME            shift and go to state 9
    LBRACK          shift and go to state 10


state 8

    (1) program -> declaration program .

    $end            reduce using rule 1 (program -> declaration program .)


state 9

    (5) fun_declaration -> type NAME . LPAR formal_pars RPAR block
    (6) fun_declaration -> type NAME . LPAR RPAR block
    (14) var_declaration -> type NAME . SEMICOLON

    LPAR            shift and go to state 11
    SEMICOLON       shift and go to state 12


state 10

    (17) type -> type LBRACK . exp RBRACK
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    lexp                           shift and go to state 17
    exp                            shift and go to state 22
    var                            shift and go to state 18

state 11

    (5) fun_declaration -> type NAME LPAR . formal_pars RPAR block
    (6) fun_declaration -> type NAME LPAR . RPAR block
    (7) formal_pars -> . formal_pars COMMA formal_par
    (8) formal_pars -> . formal_par
    (9) formal_par -> . type NAME
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    RPAR            shift and go to state 24
    INT             shift and go to state 2
    CHAR            shift and go to state 3

    formal_par                     shift and go to state 25
    type                           shift and go to state 27
    formal_pars                    shift and go to state 26

state 12

    (14) var_declaration -> type NAME SEMICOLON .

    INT             reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    CHAR            reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    $end            reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    RBRACE          reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    RETURN          reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    WRITE           reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    READ            reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    NAME            reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    WHILE           reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    IF              reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)
    LBRACE          reduce using rule 14 (var_declaration -> type NAME SEMICOLON .)


state 13

    (34) exp -> unop . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 28

state 14

    (35) exp -> LPAR . exp RPAR
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 29

state 15

    (39) exp -> QCHAR .

    MINUS           reduce using rule 39 (exp -> QCHAR .)
    PLUS            reduce using rule 39 (exp -> QCHAR .)
    TIMES           reduce using rule 39 (exp -> QCHAR .)
    DIVIDE          reduce using rule 39 (exp -> QCHAR .)
    EQUAL           reduce using rule 39 (exp -> QCHAR .)
    NEQUAL          reduce using rule 39 (exp -> QCHAR .)
    GREATER         reduce using rule 39 (exp -> QCHAR .)
    LESS            reduce using rule 39 (exp -> QCHAR .)
    RBRACE          reduce using rule 39 (exp -> QCHAR .)
    SEMICOLON       reduce using rule 39 (exp -> QCHAR .)
    ELSE            reduce using rule 39 (exp -> QCHAR .)
    RBRACK          reduce using rule 39 (exp -> QCHAR .)
    RPAR            reduce using rule 39 (exp -> QCHAR .)
    COMMA           reduce using rule 39 (exp -> QCHAR .)


state 16

    (48) unop -> MINUS .

    LENGTH          reduce using rule 48 (unop -> MINUS .)
    LPAR            reduce using rule 48 (unop -> MINUS .)
    NAME            reduce using rule 48 (unop -> MINUS .)
    NUMBER          reduce using rule 48 (unop -> MINUS .)
    QCHAR           reduce using rule 48 (unop -> MINUS .)
    MINUS           reduce using rule 48 (unop -> MINUS .)
    NOT             reduce using rule 48 (unop -> MINUS .)


state 17

    (32) exp -> lexp .
    (31) lexp -> lexp . LBRACK exp RBRACK

    MINUS           reduce using rule 32 (exp -> lexp .)
    PLUS            reduce using rule 32 (exp -> lexp .)
    TIMES           reduce using rule 32 (exp -> lexp .)
    DIVIDE          reduce using rule 32 (exp -> lexp .)
    EQUAL           reduce using rule 32 (exp -> lexp .)
    NEQUAL          reduce using rule 32 (exp -> lexp .)
    GREATER         reduce using rule 32 (exp -> lexp .)
    LESS            reduce using rule 32 (exp -> lexp .)
    RBRACE          reduce using rule 32 (exp -> lexp .)
    SEMICOLON       reduce using rule 32 (exp -> lexp .)
    ELSE            reduce using rule 32 (exp -> lexp .)
    RBRACK          reduce using rule 32 (exp -> lexp .)
    RPAR            reduce using rule 32 (exp -> lexp .)
    COMMA           reduce using rule 32 (exp -> lexp .)
    LBRACK          shift and go to state 30


state 18

    (30) lexp -> var .

    LBRACK          reduce using rule 30 (lexp -> var .)
    RBRACK          reduce using rule 30 (lexp -> var .)
    MINUS           reduce using rule 30 (lexp -> var .)
    PLUS            reduce using rule 30 (lexp -> var .)
    TIMES           reduce using rule 30 (lexp -> var .)
    DIVIDE          reduce using rule 30 (lexp -> var .)
    EQUAL           reduce using rule 30 (lexp -> var .)
    NEQUAL          reduce using rule 30 (lexp -> var .)
    GREATER         reduce using rule 30 (lexp -> var .)
    LESS            reduce using rule 30 (lexp -> var .)
    RPAR            reduce using rule 30 (lexp -> var .)
    COMMA           reduce using rule 30 (lexp -> var .)
    RBRACE          reduce using rule 30 (lexp -> var .)
    SEMICOLON       reduce using rule 30 (lexp -> var .)
    ELSE            reduce using rule 30 (lexp -> var .)
    ASSIGN          reduce using rule 30 (lexp -> var .)


state 19

    (38) exp -> NUMBER .

    MINUS           reduce using rule 38 (exp -> NUMBER .)
    PLUS            reduce using rule 38 (exp -> NUMBER .)
    TIMES           reduce using rule 38 (exp -> NUMBER .)
    DIVIDE          reduce using rule 38 (exp -> NUMBER .)
    EQUAL           reduce using rule 38 (exp -> NUMBER .)
    NEQUAL          reduce using rule 38 (exp -> NUMBER .)
    GREATER         reduce using rule 38 (exp -> NUMBER .)
    LESS            reduce using rule 38 (exp -> NUMBER .)
    RBRACE          reduce using rule 38 (exp -> NUMBER .)
    SEMICOLON       reduce using rule 38 (exp -> NUMBER .)
    ELSE            reduce using rule 38 (exp -> NUMBER .)
    RBRACK          reduce using rule 38 (exp -> NUMBER .)
    RPAR            reduce using rule 38 (exp -> NUMBER .)
    COMMA           reduce using rule 38 (exp -> NUMBER .)


state 20

    (36) exp -> NAME . LPAR RPAR
    (37) exp -> NAME . LPAR pars RPAR
    (52) var -> NAME .

    LPAR            shift and go to state 31
    LBRACK          reduce using rule 52 (var -> NAME .)
    MINUS           reduce using rule 52 (var -> NAME .)
    PLUS            reduce using rule 52 (var -> NAME .)
    TIMES           reduce using rule 52 (var -> NAME .)
    DIVIDE          reduce using rule 52 (var -> NAME .)
    EQUAL           reduce using rule 52 (var -> NAME .)
    NEQUAL          reduce using rule 52 (var -> NAME .)
    GREATER         reduce using rule 52 (var -> NAME .)
    LESS            reduce using rule 52 (var -> NAME .)
    RBRACE          reduce using rule 52 (var -> NAME .)
    SEMICOLON       reduce using rule 52 (var -> NAME .)
    ELSE            reduce using rule 52 (var -> NAME .)
    RBRACK          reduce using rule 52 (var -> NAME .)
    RPAR            reduce using rule 52 (var -> NAME .)
    COMMA           reduce using rule 52 (var -> NAME .)


state 21

    (33) exp -> LENGTH . lexp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (52) var -> . NAME

    NAME            shift and go to state 33

    var                            shift and go to state 18
    lexp                           shift and go to state 32

state 22

    (17) type -> type LBRACK exp . RBRACK
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RBRACK          shift and go to state 37
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 23

    (49) unop -> NOT .

    LENGTH          reduce using rule 49 (unop -> NOT .)
    LPAR            reduce using rule 49 (unop -> NOT .)
    NAME            reduce using rule 49 (unop -> NOT .)
    NUMBER          reduce using rule 49 (unop -> NOT .)
    QCHAR           reduce using rule 49 (unop -> NOT .)
    MINUS           reduce using rule 49 (unop -> NOT .)
    NOT             reduce using rule 49 (unop -> NOT .)


state 24

    (6) fun_declaration -> type NAME LPAR RPAR . block
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE

    LBRACE          shift and go to state 43

    block                          shift and go to state 44

state 25

    (8) formal_pars -> formal_par .

    RPAR            reduce using rule 8 (formal_pars -> formal_par .)
    COMMA           reduce using rule 8 (formal_pars -> formal_par .)


state 26

    (5) fun_declaration -> type NAME LPAR formal_pars . RPAR block
    (7) formal_pars -> formal_pars . COMMA formal_par

    RPAR            shift and go to state 45
    COMMA           shift and go to state 46


state 27

    (9) formal_par -> type . NAME
    (17) type -> type . LBRACK exp RBRACK

    NAME            shift and go to state 47
    LBRACK          shift and go to state 10


state 28

    (34) exp -> unop exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
    RBRACE          reduce using rule 34 (exp -> unop exp .)
    SEMICOLON       reduce using rule 34 (exp -> unop exp .)
    ELSE            reduce using rule 34 (exp -> unop exp .)
    RBRACK          reduce using rule 34 (exp -> unop exp .)
    RPAR            reduce using rule 34 (exp -> unop exp .)
    COMMA           reduce using rule 34 (exp -> unop exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35

  ! MINUS           [ reduce using rule 34 (exp -> unop exp .) ]
  ! PLUS            [ reduce using rule 34 (exp -> unop exp .) ]
  ! TIMES           [ reduce using rule 34 (exp -> unop exp .) ]
  ! DIVIDE          [ reduce using rule 34 (exp -> unop exp .) ]
  ! EQUAL           [ reduce using rule 34 (exp -> unop exp .) ]
  ! NEQUAL          [ reduce using rule 34 (exp -> unop exp .) ]
  ! GREATER         [ reduce using rule 34 (exp -> unop exp .) ]
  ! LESS            [ reduce using rule 34 (exp -> unop exp .) ]


state 29

    (35) exp -> LPAR exp . RPAR
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RPAR            shift and go to state 48
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 30

    (31) lexp -> lexp LBRACK . exp RBRACK
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 49

state 31

    (36) exp -> NAME LPAR . RPAR
    (37) exp -> NAME LPAR . pars RPAR
    (50) pars -> . pars COMMA exp
    (51) pars -> . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    RPAR            shift and go to state 50
    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    pars                           shift and go to state 51
    lexp                           shift and go to state 17
    exp                            shift and go to state 52

state 32

    (33) exp -> LENGTH lexp .
    (31) lexp -> lexp . LBRACK exp RBRACK

    MINUS           reduce using rule 33 (exp -> LENGTH lexp .)
    PLUS            reduce using rule 33 (exp -> LENGTH lexp .)
    TIMES           reduce using rule 33 (exp -> LENGTH lexp .)
    DIVIDE          reduce using rule 33 (exp -> LENGTH lexp .)
    EQUAL           reduce using rule 33 (exp -> LENGTH lexp .)
    NEQUAL          reduce using rule 33 (exp -> LENGTH lexp .)
    GREATER         reduce using rule 33 (exp -> LENGTH lexp .)
    LESS            reduce using rule 33 (exp -> LENGTH lexp .)
    RBRACE          reduce using rule 33 (exp -> LENGTH lexp .)
    SEMICOLON       reduce using rule 33 (exp -> LENGTH lexp .)
    ELSE            reduce using rule 33 (exp -> LENGTH lexp .)
    RBRACK          reduce using rule 33 (exp -> LENGTH lexp .)
    RPAR            reduce using rule 33 (exp -> LENGTH lexp .)
    COMMA           reduce using rule 33 (exp -> LENGTH lexp .)
    LBRACK          shift and go to state 30


state 33

    (52) var -> NAME .

    LBRACK          reduce using rule 52 (var -> NAME .)
    RBRACE          reduce using rule 52 (var -> NAME .)
    SEMICOLON       reduce using rule 52 (var -> NAME .)
    ELSE            reduce using rule 52 (var -> NAME .)
    RBRACK          reduce using rule 52 (var -> NAME .)
    MINUS           reduce using rule 52 (var -> NAME .)
    PLUS            reduce using rule 52 (var -> NAME .)
    TIMES           reduce using rule 52 (var -> NAME .)
    DIVIDE          reduce using rule 52 (var -> NAME .)
    EQUAL           reduce using rule 52 (var -> NAME .)
    NEQUAL          reduce using rule 52 (var -> NAME .)
    GREATER         reduce using rule 52 (var -> NAME .)
    LESS            reduce using rule 52 (var -> NAME .)
    RPAR            reduce using rule 52 (var -> NAME .)
    COMMA           reduce using rule 52 (var -> NAME .)


state 34

    (43) exp -> exp DIVIDE . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 53

state 35

    (47) exp -> exp LESS . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 54

state 36

    (44) exp -> exp EQUAL . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 55

state 37

    (17) type -> type LBRACK exp RBRACK .

    NAME            reduce using rule 17 (type -> type LBRACK exp RBRACK .)
    LBRACK          reduce using rule 17 (type -> type LBRACK exp RBRACK .)


state 38

    (45) exp -> exp NEQUAL . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 56

state 39

    (42) exp -> exp TIMES . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 57

state 40

    (41) exp -> exp PLUS . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 58

state 41

    (40) exp -> exp MINUS . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 59

state 42

    (46) exp -> exp GREATER . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 60

state 43

    (10) block -> LBRACE . var_declarations statements RBRACE
    (11) block -> LBRACE . var_declarations RBRACE
    (12) var_declarations -> . var_declaration var_declarations
    (13) var_declarations -> . empty
    (14) var_declaration -> . type NAME SEMICOLON
    (53) empty -> .
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    RBRACE          reduce using rule 53 (empty -> .)
    RETURN          reduce using rule 53 (empty -> .)
    WRITE           reduce using rule 53 (empty -> .)
    READ            reduce using rule 53 (empty -> .)
    NAME            reduce using rule 53 (empty -> .)
    WHILE           reduce using rule 53 (empty -> .)
    IF              reduce using rule 53 (empty -> .)
    LBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 2
    CHAR            shift and go to state 3

    var_declaration                shift and go to state 61
    var_declarations               shift and go to state 62
    type                           shift and go to state 63
    empty                          shift and go to state 64

state 44

    (6) fun_declaration -> type NAME LPAR RPAR block .

    INT             reduce using rule 6 (fun_declaration -> type NAME LPAR RPAR block .)
    CHAR            reduce using rule 6 (fun_declaration -> type NAME LPAR RPAR block .)
    $end            reduce using rule 6 (fun_declaration -> type NAME LPAR RPAR block .)


state 45

    (5) fun_declaration -> type NAME LPAR formal_pars RPAR . block
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE

    LBRACE          shift and go to state 43

    block                          shift and go to state 65

state 46

    (7) formal_pars -> formal_pars COMMA . formal_par
    (9) formal_par -> . type NAME
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    INT             shift and go to state 2
    CHAR            shift and go to state 3

    formal_par                     shift and go to state 66
    type                           shift and go to state 27

state 47

    (9) formal_par -> type NAME .

    RPAR            reduce using rule 9 (formal_par -> type NAME .)
    COMMA           reduce using rule 9 (formal_par -> type NAME .)


state 48

    (35) exp -> LPAR exp RPAR .

    MINUS           reduce using rule 35 (exp -> LPAR exp RPAR .)
    PLUS            reduce using rule 35 (exp -> LPAR exp RPAR .)
    TIMES           reduce using rule 35 (exp -> LPAR exp RPAR .)
    DIVIDE          reduce using rule 35 (exp -> LPAR exp RPAR .)
    EQUAL           reduce using rule 35 (exp -> LPAR exp RPAR .)
    NEQUAL          reduce using rule 35 (exp -> LPAR exp RPAR .)
    GREATER         reduce using rule 35 (exp -> LPAR exp RPAR .)
    LESS            reduce using rule 35 (exp -> LPAR exp RPAR .)
    RBRACE          reduce using rule 35 (exp -> LPAR exp RPAR .)
    SEMICOLON       reduce using rule 35 (exp -> LPAR exp RPAR .)
    ELSE            reduce using rule 35 (exp -> LPAR exp RPAR .)
    RBRACK          reduce using rule 35 (exp -> LPAR exp RPAR .)
    RPAR            reduce using rule 35 (exp -> LPAR exp RPAR .)
    COMMA           reduce using rule 35 (exp -> LPAR exp RPAR .)


state 49

    (31) lexp -> lexp LBRACK exp . RBRACK
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RBRACK          shift and go to state 67
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 50

    (36) exp -> NAME LPAR RPAR .

    MINUS           reduce using rule 36 (exp -> NAME LPAR RPAR .)
    PLUS            reduce using rule 36 (exp -> NAME LPAR RPAR .)
    TIMES           reduce using rule 36 (exp -> NAME LPAR RPAR .)
    DIVIDE          reduce using rule 36 (exp -> NAME LPAR RPAR .)
    EQUAL           reduce using rule 36 (exp -> NAME LPAR RPAR .)
    NEQUAL          reduce using rule 36 (exp -> NAME LPAR RPAR .)
    GREATER         reduce using rule 36 (exp -> NAME LPAR RPAR .)
    LESS            reduce using rule 36 (exp -> NAME LPAR RPAR .)
    RBRACE          reduce using rule 36 (exp -> NAME LPAR RPAR .)
    SEMICOLON       reduce using rule 36 (exp -> NAME LPAR RPAR .)
    ELSE            reduce using rule 36 (exp -> NAME LPAR RPAR .)
    RBRACK          reduce using rule 36 (exp -> NAME LPAR RPAR .)
    RPAR            reduce using rule 36 (exp -> NAME LPAR RPAR .)
    COMMA           reduce using rule 36 (exp -> NAME LPAR RPAR .)


state 51

    (37) exp -> NAME LPAR pars . RPAR
    (50) pars -> pars . COMMA exp

    RPAR            shift and go to state 68
    COMMA           shift and go to state 69


state 52

    (51) pars -> exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RPAR            reduce using rule 51 (pars -> exp .)
    COMMA           reduce using rule 51 (pars -> exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 53

    (43) exp -> exp DIVIDE exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    MINUS           reduce using rule 43 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 43 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 43 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 43 (exp -> exp DIVIDE exp .)
    EQUAL           reduce using rule 43 (exp -> exp DIVIDE exp .)
    NEQUAL          reduce using rule 43 (exp -> exp DIVIDE exp .)
    GREATER         reduce using rule 43 (exp -> exp DIVIDE exp .)
    LESS            reduce using rule 43 (exp -> exp DIVIDE exp .)
    RBRACE          reduce using rule 43 (exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 43 (exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 43 (exp -> exp DIVIDE exp .)
    RBRACK          reduce using rule 43 (exp -> exp DIVIDE exp .)
    RPAR            reduce using rule 43 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 43 (exp -> exp DIVIDE exp .)

  ! MINUS           [ shift and go to state 41 ]
  ! PLUS            [ shift and go to state 40 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! EQUAL           [ shift and go to state 36 ]
  ! NEQUAL          [ shift and go to state 38 ]
  ! GREATER         [ shift and go to state 42 ]
  ! LESS            [ shift and go to state 35 ]


state 54

    (47) exp -> exp LESS exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    EQUAL           reduce using rule 47 (exp -> exp LESS exp .)
    NEQUAL          reduce using rule 47 (exp -> exp LESS exp .)
    GREATER         reduce using rule 47 (exp -> exp LESS exp .)
    LESS            reduce using rule 47 (exp -> exp LESS exp .)
    RBRACE          reduce using rule 47 (exp -> exp LESS exp .)
    SEMICOLON       reduce using rule 47 (exp -> exp LESS exp .)
    ELSE            reduce using rule 47 (exp -> exp LESS exp .)
    RBRACK          reduce using rule 47 (exp -> exp LESS exp .)
    RPAR            reduce using rule 47 (exp -> exp LESS exp .)
    COMMA           reduce using rule 47 (exp -> exp LESS exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34

  ! MINUS           [ reduce using rule 47 (exp -> exp LESS exp .) ]
  ! PLUS            [ reduce using rule 47 (exp -> exp LESS exp .) ]
  ! TIMES           [ reduce using rule 47 (exp -> exp LESS exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> exp LESS exp .) ]
  ! EQUAL           [ shift and go to state 36 ]
  ! NEQUAL          [ shift and go to state 38 ]
  ! GREATER         [ shift and go to state 42 ]
  ! LESS            [ shift and go to state 35 ]


state 55

    (44) exp -> exp EQUAL exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    EQUAL           reduce using rule 44 (exp -> exp EQUAL exp .)
    NEQUAL          reduce using rule 44 (exp -> exp EQUAL exp .)
    RBRACE          reduce using rule 44 (exp -> exp EQUAL exp .)
    SEMICOLON       reduce using rule 44 (exp -> exp EQUAL exp .)
    ELSE            reduce using rule 44 (exp -> exp EQUAL exp .)
    RBRACK          reduce using rule 44 (exp -> exp EQUAL exp .)
    RPAR            reduce using rule 44 (exp -> exp EQUAL exp .)
    COMMA           reduce using rule 44 (exp -> exp EQUAL exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    GREATER         shift and go to state 42
    LESS            shift and go to state 35

  ! MINUS           [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! PLUS            [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! TIMES           [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! GREATER         [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! LESS            [ reduce using rule 44 (exp -> exp EQUAL exp .) ]
  ! EQUAL           [ shift and go to state 36 ]
  ! NEQUAL          [ shift and go to state 38 ]


state 56

    (45) exp -> exp NEQUAL exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    EQUAL           reduce using rule 45 (exp -> exp NEQUAL exp .)
    NEQUAL          reduce using rule 45 (exp -> exp NEQUAL exp .)
    RBRACE          reduce using rule 45 (exp -> exp NEQUAL exp .)
    SEMICOLON       reduce using rule 45 (exp -> exp NEQUAL exp .)
    ELSE            reduce using rule 45 (exp -> exp NEQUAL exp .)
    RBRACK          reduce using rule 45 (exp -> exp NEQUAL exp .)
    RPAR            reduce using rule 45 (exp -> exp NEQUAL exp .)
    COMMA           reduce using rule 45 (exp -> exp NEQUAL exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    GREATER         shift and go to state 42
    LESS            shift and go to state 35

  ! MINUS           [ reduce using rule 45 (exp -> exp NEQUAL exp .) ]
  ! PLUS            [ reduce using rule 45 (exp -> exp NEQUAL exp .) ]
  ! TIMES           [ reduce using rule 45 (exp -> exp NEQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 45 (exp -> exp NEQUAL exp .) ]
  ! GREATER         [ reduce using rule 45 (exp -> exp NEQUAL exp .) ]
  ! LESS            [ reduce using rule 45 (exp -> exp NEQUAL exp .) ]
  ! EQUAL           [ shift and go to state 36 ]
  ! NEQUAL          [ shift and go to state 38 ]


state 57

    (42) exp -> exp TIMES exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    MINUS           reduce using rule 42 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 42 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 42 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 42 (exp -> exp TIMES exp .)
    EQUAL           reduce using rule 42 (exp -> exp TIMES exp .)
    NEQUAL          reduce using rule 42 (exp -> exp TIMES exp .)
    GREATER         reduce using rule 42 (exp -> exp TIMES exp .)
    LESS            reduce using rule 42 (exp -> exp TIMES exp .)
    RBRACE          reduce using rule 42 (exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 42 (exp -> exp TIMES exp .)
    ELSE            reduce using rule 42 (exp -> exp TIMES exp .)
    RBRACK          reduce using rule 42 (exp -> exp TIMES exp .)
    RPAR            reduce using rule 42 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 42 (exp -> exp TIMES exp .)

  ! MINUS           [ shift and go to state 41 ]
  ! PLUS            [ shift and go to state 40 ]
  ! TIMES           [ shift and go to state 39 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! EQUAL           [ shift and go to state 36 ]
  ! NEQUAL          [ shift and go to state 38 ]
  ! GREATER         [ shift and go to state 42 ]
  ! LESS            [ shift and go to state 35 ]


state 58

    (41) exp -> exp PLUS exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    MINUS           reduce using rule 41 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 41 (exp -> exp PLUS exp .)
    EQUAL           reduce using rule 41 (exp -> exp PLUS exp .)
    NEQUAL          reduce using rule 41 (exp -> exp PLUS exp .)
    GREATER         reduce using rule 41 (exp -> exp PLUS exp .)
    LESS            reduce using rule 41 (exp -> exp PLUS exp .)
    RBRACE          reduce using rule 41 (exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 41 (exp -> exp PLUS exp .)
    ELSE            reduce using rule 41 (exp -> exp PLUS exp .)
    RBRACK          reduce using rule 41 (exp -> exp PLUS exp .)
    RPAR            reduce using rule 41 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 41 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34

  ! TIMES           [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! MINUS           [ shift and go to state 41 ]
  ! PLUS            [ shift and go to state 40 ]
  ! EQUAL           [ shift and go to state 36 ]
  ! NEQUAL          [ shift and go to state 38 ]
  ! GREATER         [ shift and go to state 42 ]
  ! LESS            [ shift and go to state 35 ]


state 59

    (40) exp -> exp MINUS exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    MINUS           reduce using rule 40 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 40 (exp -> exp MINUS exp .)
    EQUAL           reduce using rule 40 (exp -> exp MINUS exp .)
    NEQUAL          reduce using rule 40 (exp -> exp MINUS exp .)
    GREATER         reduce using rule 40 (exp -> exp MINUS exp .)
    LESS            reduce using rule 40 (exp -> exp MINUS exp .)
    RBRACE          reduce using rule 40 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 40 (exp -> exp MINUS exp .)
    ELSE            reduce using rule 40 (exp -> exp MINUS exp .)
    RBRACK          reduce using rule 40 (exp -> exp MINUS exp .)
    RPAR            reduce using rule 40 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 40 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34

  ! TIMES           [ reduce using rule 40 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 40 (exp -> exp MINUS exp .) ]
  ! MINUS           [ shift and go to state 41 ]
  ! PLUS            [ shift and go to state 40 ]
  ! EQUAL           [ shift and go to state 36 ]
  ! NEQUAL          [ shift and go to state 38 ]
  ! GREATER         [ shift and go to state 42 ]
  ! LESS            [ shift and go to state 35 ]


state 60

    (46) exp -> exp GREATER exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    EQUAL           reduce using rule 46 (exp -> exp GREATER exp .)
    NEQUAL          reduce using rule 46 (exp -> exp GREATER exp .)
    GREATER         reduce using rule 46 (exp -> exp GREATER exp .)
    LESS            reduce using rule 46 (exp -> exp GREATER exp .)
    RBRACE          reduce using rule 46 (exp -> exp GREATER exp .)
    SEMICOLON       reduce using rule 46 (exp -> exp GREATER exp .)
    ELSE            reduce using rule 46 (exp -> exp GREATER exp .)
    RBRACK          reduce using rule 46 (exp -> exp GREATER exp .)
    RPAR            reduce using rule 46 (exp -> exp GREATER exp .)
    COMMA           reduce using rule 46 (exp -> exp GREATER exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34

  ! MINUS           [ reduce using rule 46 (exp -> exp GREATER exp .) ]
  ! PLUS            [ reduce using rule 46 (exp -> exp GREATER exp .) ]
  ! TIMES           [ reduce using rule 46 (exp -> exp GREATER exp .) ]
  ! DIVIDE          [ reduce using rule 46 (exp -> exp GREATER exp .) ]
  ! EQUAL           [ shift and go to state 36 ]
  ! NEQUAL          [ shift and go to state 38 ]
  ! GREATER         [ shift and go to state 42 ]
  ! LESS            [ shift and go to state 35 ]


state 61

    (12) var_declarations -> var_declaration . var_declarations
    (12) var_declarations -> . var_declaration var_declarations
    (13) var_declarations -> . empty
    (14) var_declaration -> . type NAME SEMICOLON
    (53) empty -> .
    (15) type -> . INT
    (16) type -> . CHAR
    (17) type -> . type LBRACK exp RBRACK

    RBRACE          reduce using rule 53 (empty -> .)
    RETURN          reduce using rule 53 (empty -> .)
    WRITE           reduce using rule 53 (empty -> .)
    READ            reduce using rule 53 (empty -> .)
    NAME            reduce using rule 53 (empty -> .)
    WHILE           reduce using rule 53 (empty -> .)
    IF              reduce using rule 53 (empty -> .)
    LBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 2
    CHAR            shift and go to state 3

    var_declaration                shift and go to state 61
    type                           shift and go to state 63
    empty                          shift and go to state 64
    var_declarations               shift and go to state 70

state 62

    (10) block -> LBRACE var_declarations . statements RBRACE
    (11) block -> LBRACE var_declarations . RBRACE
    (18) statements -> . statements SEMICOLON statement
    (19) statements -> . statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (52) var -> . NAME

    RBRACE          shift and go to state 77
    RETURN          shift and go to state 71
    WRITE           shift and go to state 78
    READ            shift and go to state 72
    NAME            shift and go to state 80
    WHILE           shift and go to state 73
    IF              shift and go to state 79
    LBRACE          shift and go to state 43

    statements                     shift and go to state 74
    statement                      shift and go to state 76
    var                            shift and go to state 18
    block                          shift and go to state 81
    lexp                           shift and go to state 75

state 63

    (14) var_declaration -> type . NAME SEMICOLON
    (17) type -> type . LBRACK exp RBRACK

    NAME            shift and go to state 82
    LBRACK          shift and go to state 10


state 64

    (13) var_declarations -> empty .

    RBRACE          reduce using rule 13 (var_declarations -> empty .)
    RETURN          reduce using rule 13 (var_declarations -> empty .)
    WRITE           reduce using rule 13 (var_declarations -> empty .)
    READ            reduce using rule 13 (var_declarations -> empty .)
    NAME            reduce using rule 13 (var_declarations -> empty .)
    WHILE           reduce using rule 13 (var_declarations -> empty .)
    IF              reduce using rule 13 (var_declarations -> empty .)
    LBRACE          reduce using rule 13 (var_declarations -> empty .)


state 65

    (5) fun_declaration -> type NAME LPAR formal_pars RPAR block .

    INT             reduce using rule 5 (fun_declaration -> type NAME LPAR formal_pars RPAR block .)
    CHAR            reduce using rule 5 (fun_declaration -> type NAME LPAR formal_pars RPAR block .)
    $end            reduce using rule 5 (fun_declaration -> type NAME LPAR formal_pars RPAR block .)


state 66

    (7) formal_pars -> formal_pars COMMA formal_par .

    RPAR            reduce using rule 7 (formal_pars -> formal_pars COMMA formal_par .)
    COMMA           reduce using rule 7 (formal_pars -> formal_pars COMMA formal_par .)


state 67

    (31) lexp -> lexp LBRACK exp RBRACK .

    LBRACK          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    RBRACK          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    MINUS           reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    PLUS            reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    TIMES           reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    DIVIDE          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    EQUAL           reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    NEQUAL          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    GREATER         reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    LESS            reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    RPAR            reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    COMMA           reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    RBRACE          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    SEMICOLON       reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    ELSE            reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)
    ASSIGN          reduce using rule 31 (lexp -> lexp LBRACK exp RBRACK .)


state 68

    (37) exp -> NAME LPAR pars RPAR .

    MINUS           reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    PLUS            reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    TIMES           reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    DIVIDE          reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    EQUAL           reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    NEQUAL          reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    GREATER         reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    LESS            reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    RBRACE          reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    SEMICOLON       reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    ELSE            reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    RBRACK          reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    RPAR            reduce using rule 37 (exp -> NAME LPAR pars RPAR .)
    COMMA           reduce using rule 37 (exp -> NAME LPAR pars RPAR .)


state 69

    (50) pars -> pars COMMA . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 83

state 70

    (12) var_declarations -> var_declaration var_declarations .

    RBRACE          reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    RETURN          reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    WRITE           reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    READ            reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    NAME            reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    WHILE           reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    IF              reduce using rule 12 (var_declarations -> var_declaration var_declarations .)
    LBRACE          reduce using rule 12 (var_declarations -> var_declaration var_declarations .)


state 71

    (21) statement -> RETURN . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 84

state 72

    (23) statement -> READ . lexp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (52) var -> . NAME

    NAME            shift and go to state 33

    var                            shift and go to state 18
    lexp                           shift and go to state 85

state 73

    (26) statement -> WHILE . LPAR exp RPAR statement

    LPAR            shift and go to state 86


state 74

    (10) block -> LBRACE var_declarations statements . RBRACE
    (18) statements -> statements . SEMICOLON statement

    RBRACE          shift and go to state 87
    SEMICOLON       shift and go to state 88


state 75

    (29) statement -> lexp . ASSIGN exp
    (31) lexp -> lexp . LBRACK exp RBRACK

    ASSIGN          shift and go to state 89
    LBRACK          shift and go to state 30


state 76

    (19) statements -> statement .

    RBRACE          reduce using rule 19 (statements -> statement .)
    SEMICOLON       reduce using rule 19 (statements -> statement .)


state 77

    (11) block -> LBRACE var_declarations RBRACE .

    INT             reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    CHAR            reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    $end            reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    RBRACE          reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    SEMICOLON       reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)
    ELSE            reduce using rule 11 (block -> LBRACE var_declarations RBRACE .)


state 78

    (22) statement -> WRITE . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 90

state 79

    (27) statement -> IF . LPAR exp RPAR statement
    (28) statement -> IF . LPAR exp RPAR statement ELSE statement

    LPAR            shift and go to state 91


state 80

    (24) statement -> NAME . LPAR RPAR
    (25) statement -> NAME . LPAR pars RPAR
    (52) var -> NAME .

    LPAR            shift and go to state 92
    ASSIGN          reduce using rule 52 (var -> NAME .)
    LBRACK          reduce using rule 52 (var -> NAME .)


state 81

    (20) statement -> block .

    RBRACE          reduce using rule 20 (statement -> block .)
    SEMICOLON       reduce using rule 20 (statement -> block .)
    ELSE            reduce using rule 20 (statement -> block .)


state 82

    (14) var_declaration -> type NAME . SEMICOLON

    SEMICOLON       shift and go to state 12


state 83

    (50) pars -> pars COMMA exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RPAR            reduce using rule 50 (pars -> pars COMMA exp .)
    COMMA           reduce using rule 50 (pars -> pars COMMA exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 84

    (21) statement -> RETURN exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RBRACE          reduce using rule 21 (statement -> RETURN exp .)
    SEMICOLON       reduce using rule 21 (statement -> RETURN exp .)
    ELSE            reduce using rule 21 (statement -> RETURN exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 85

    (23) statement -> READ lexp .
    (31) lexp -> lexp . LBRACK exp RBRACK

    RBRACE          reduce using rule 23 (statement -> READ lexp .)
    SEMICOLON       reduce using rule 23 (statement -> READ lexp .)
    ELSE            reduce using rule 23 (statement -> READ lexp .)
    LBRACK          shift and go to state 30


state 86

    (26) statement -> WHILE LPAR . exp RPAR statement
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    exp                            shift and go to state 93
    var                            shift and go to state 18
    lexp                           shift and go to state 17

state 87

    (10) block -> LBRACE var_declarations statements RBRACE .

    INT             reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    CHAR            reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    $end            reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    RBRACE          reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    SEMICOLON       reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)
    ELSE            reduce using rule 10 (block -> LBRACE var_declarations statements RBRACE .)


state 88

    (18) statements -> statements SEMICOLON . statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (52) var -> . NAME

    RETURN          shift and go to state 71
    WRITE           shift and go to state 78
    READ            shift and go to state 72
    NAME            shift and go to state 80
    WHILE           shift and go to state 73
    IF              shift and go to state 79
    LBRACE          shift and go to state 43

    statement                      shift and go to state 94
    var                            shift and go to state 18
    block                          shift and go to state 81
    lexp                           shift and go to state 75

state 89

    (29) statement -> lexp ASSIGN . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    lexp                           shift and go to state 17
    exp                            shift and go to state 95

state 90

    (22) statement -> WRITE exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RBRACE          reduce using rule 22 (statement -> WRITE exp .)
    SEMICOLON       reduce using rule 22 (statement -> WRITE exp .)
    ELSE            reduce using rule 22 (statement -> WRITE exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 91

    (27) statement -> IF LPAR . exp RPAR statement
    (28) statement -> IF LPAR . exp RPAR statement ELSE statement
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    exp                            shift and go to state 96
    var                            shift and go to state 18
    lexp                           shift and go to state 17

state 92

    (24) statement -> NAME LPAR . RPAR
    (25) statement -> NAME LPAR . pars RPAR
    (50) pars -> . pars COMMA exp
    (51) pars -> . exp
    (32) exp -> . lexp
    (33) exp -> . LENGTH lexp
    (34) exp -> . unop exp
    (35) exp -> . LPAR exp RPAR
    (36) exp -> . NAME LPAR RPAR
    (37) exp -> . NAME LPAR pars RPAR
    (38) exp -> . NUMBER
    (39) exp -> . QCHAR
    (40) exp -> . exp MINUS exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp TIMES exp
    (43) exp -> . exp DIVIDE exp
    (44) exp -> . exp EQUAL exp
    (45) exp -> . exp NEQUAL exp
    (46) exp -> . exp GREATER exp
    (47) exp -> . exp LESS exp
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (48) unop -> . MINUS
    (49) unop -> . NOT
    (52) var -> . NAME

    RPAR            shift and go to state 97
    LENGTH          shift and go to state 21
    LPAR            shift and go to state 14
    NAME            shift and go to state 20
    NUMBER          shift and go to state 19
    QCHAR           shift and go to state 15
    MINUS           shift and go to state 16
    NOT             shift and go to state 23

    unop                           shift and go to state 13
    var                            shift and go to state 18
    pars                           shift and go to state 98
    lexp                           shift and go to state 17
    exp                            shift and go to state 52

state 93

    (26) statement -> WHILE LPAR exp . RPAR statement
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RPAR            shift and go to state 99
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 94

    (18) statements -> statements SEMICOLON statement .

    RBRACE          reduce using rule 18 (statements -> statements SEMICOLON statement .)
    SEMICOLON       reduce using rule 18 (statements -> statements SEMICOLON statement .)


state 95

    (29) statement -> lexp ASSIGN exp .
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RBRACE          reduce using rule 29 (statement -> lexp ASSIGN exp .)
    SEMICOLON       reduce using rule 29 (statement -> lexp ASSIGN exp .)
    ELSE            reduce using rule 29 (statement -> lexp ASSIGN exp .)
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 96

    (27) statement -> IF LPAR exp . RPAR statement
    (28) statement -> IF LPAR exp . RPAR statement ELSE statement
    (40) exp -> exp . MINUS exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . TIMES exp
    (43) exp -> exp . DIVIDE exp
    (44) exp -> exp . EQUAL exp
    (45) exp -> exp . NEQUAL exp
    (46) exp -> exp . GREATER exp
    (47) exp -> exp . LESS exp

    RPAR            shift and go to state 100
    MINUS           shift and go to state 41
    PLUS            shift and go to state 40
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 34
    EQUAL           shift and go to state 36
    NEQUAL          shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 35


state 97

    (24) statement -> NAME LPAR RPAR .

    RBRACE          reduce using rule 24 (statement -> NAME LPAR RPAR .)
    SEMICOLON       reduce using rule 24 (statement -> NAME LPAR RPAR .)
    ELSE            reduce using rule 24 (statement -> NAME LPAR RPAR .)


state 98

    (25) statement -> NAME LPAR pars . RPAR
    (50) pars -> pars . COMMA exp

    RPAR            shift and go to state 101
    COMMA           shift and go to state 69


state 99

    (26) statement -> WHILE LPAR exp RPAR . statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (52) var -> . NAME

    RETURN          shift and go to state 71
    WRITE           shift and go to state 78
    READ            shift and go to state 72
    NAME            shift and go to state 80
    WHILE           shift and go to state 73
    IF              shift and go to state 79
    LBRACE          shift and go to state 43

    statement                      shift and go to state 102
    var                            shift and go to state 18
    block                          shift and go to state 81
    lexp                           shift and go to state 75

state 100

    (27) statement -> IF LPAR exp RPAR . statement
    (28) statement -> IF LPAR exp RPAR . statement ELSE statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (52) var -> . NAME

    RETURN          shift and go to state 71
    WRITE           shift and go to state 78
    READ            shift and go to state 72
    NAME            shift and go to state 80
    WHILE           shift and go to state 73
    IF              shift and go to state 79
    LBRACE          shift and go to state 43

    statement                      shift and go to state 103
    var                            shift and go to state 18
    block                          shift and go to state 81
    lexp                           shift and go to state 75

state 101

    (25) statement -> NAME LPAR pars RPAR .

    RBRACE          reduce using rule 25 (statement -> NAME LPAR pars RPAR .)
    SEMICOLON       reduce using rule 25 (statement -> NAME LPAR pars RPAR .)
    ELSE            reduce using rule 25 (statement -> NAME LPAR pars RPAR .)


state 102

    (26) statement -> WHILE LPAR exp RPAR statement .

    RBRACE          reduce using rule 26 (statement -> WHILE LPAR exp RPAR statement .)
    SEMICOLON       reduce using rule 26 (statement -> WHILE LPAR exp RPAR statement .)
    ELSE            reduce using rule 26 (statement -> WHILE LPAR exp RPAR statement .)


state 103

    (27) statement -> IF LPAR exp RPAR statement .
    (28) statement -> IF LPAR exp RPAR statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    RBRACE          reduce using rule 27 (statement -> IF LPAR exp RPAR statement .)
    SEMICOLON       reduce using rule 27 (statement -> IF LPAR exp RPAR statement .)
    ELSE            shift and go to state 104

  ! ELSE            [ reduce using rule 27 (statement -> IF LPAR exp RPAR statement .) ]


state 104

    (28) statement -> IF LPAR exp RPAR statement ELSE . statement
    (20) statement -> . block
    (21) statement -> . RETURN exp
    (22) statement -> . WRITE exp
    (23) statement -> . READ lexp
    (24) statement -> . NAME LPAR RPAR
    (25) statement -> . NAME LPAR pars RPAR
    (26) statement -> . WHILE LPAR exp RPAR statement
    (27) statement -> . IF LPAR exp RPAR statement
    (28) statement -> . IF LPAR exp RPAR statement ELSE statement
    (29) statement -> . lexp ASSIGN exp
    (10) block -> . LBRACE var_declarations statements RBRACE
    (11) block -> . LBRACE var_declarations RBRACE
    (30) lexp -> . var
    (31) lexp -> . lexp LBRACK exp RBRACK
    (52) var -> . NAME

    RETURN          shift and go to state 71
    WRITE           shift and go to state 78
    READ            shift and go to state 72
    NAME            shift and go to state 80
    WHILE           shift and go to state 73
    IF              shift and go to state 79
    LBRACE          shift and go to state 43

    statement                      shift and go to state 105
    var                            shift and go to state 18
    block                          shift and go to state 81
    lexp                           shift and go to state 75

state 105

    (28) statement -> IF LPAR exp RPAR statement ELSE statement .

    RBRACE          reduce using rule 28 (statement -> IF LPAR exp RPAR statement ELSE statement .)
    SEMICOLON       reduce using rule 28 (statement -> IF LPAR exp RPAR statement ELSE statement .)
    ELSE            reduce using rule 28 (statement -> IF LPAR exp RPAR statement ELSE statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 28 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 28 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 28 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 28 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 28 resolved as shift
WARNING: shift/reduce conflict for NEQUAL in state 28 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 28 resolved as shift
WARNING: shift/reduce conflict for LESS in state 28 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 103 resolved as shift
