#-------------------------------------------------------------------------------
# Name:         my_assembler.py
# Purpose:      Assemble an IR Abstract Syntax Tree to 8086 NASM assembly
#
# Author:       David Sverdlov
# Course:       Compilers, june 2015
#-------------------------------------------------------------------------------
from node import *
import labelmaker
from typechecker import *

class assembler(object):
    def __init__(self, tree):
        self.labels = labelmaker.labelmaker()

        # The Assembly program
        self.assembly = ""

        # Initialized data
        self.data = ['readint db \t"Enter an integer: ", 0',
                'readstr db \t"Enter a string: ", 0',
                'readchar db \t"Enter a char: ", 0',
                ]

        # Uninitialized data
        self.bss = []

        # Code Instructions
        self.code = []

        self.binops =  { '+' : 'add',
                    '-' : 'sub',
                    '/' : 'idiv',
                    '*' : 'imul',
                    }
        self.conds = {'==' : 'je',
                 '!=' : 'jne',
                 '>' : 'jg',
                 '>=' : 'jge',
                 '<' : 'jl',
                 '<=' : 'jle',
                 }

        self.assemble_loop(tree)
        self.generate()

    def write_to_file(self, sourceFilename, targetFilename):
        with open(targetFilename, 'w') as f:

            pre = ";\n; ASSEMBLY OUTPUT FOR: {}\n".format(sourceFilename)
            pre += ";\n; Generated by TINY->ASM compiler\n"
            pre += ";\n; Author David Sverdlov\n"
            pre += ";\n; Assembled via: nasm.exe -f win32 gen.asm\n"
            pre += ";\n; Linked via: gcc gen.obj driver.c asm_io.obj\n"
            pre += "\n\n%include 'asm_io.inc'"
            f.write("{}{}\n".format(pre, self.assembly))

    def add(self, line):
        self.code.append(line)

    def add_bss(self, varname = None):
        i = len(self.bss)
        if varname is None:
            varname = 'input'+str(i)
        self.bss.append(varname + '\t resd 1')
        return varname

    def add_data(self, name, string):
        self.data.append(name+' db \t"'+string+'", 0')

    def generate(self):
        self.assembly += "\n; Initialized data"
        self.assembly += "\nsegment .data"
        for line in self.data:
            self.assembly += "\n" + line

        self.assembly += "\n; Uninitialized data"
        self.assembly += "\nsegment .bss"
        for inp in self.bss:
            self.assembly += "\n" + inp

        self.assembly += "\n\nsegment .code\n\tglobal _asm_main"
        for line in self.code:
            self.assembly += "\n" + line

        #print self.assembly

    def process_print_string(self, name): # must be in data
        self.add('\t mov \t eax, {} \t\t; Printing string'.format(name))
        self.add('\t call \t print_string')

    def process_write(self, tree):
        tree = tree.children[0]
        if not tree.is_leaf():
            self.assemble_loop(tree)
        elif tree.data == 'VAR':
            # If we want to write a variable, the call is dependend on the type
            varType = find_type_of_var(tree.parent, tree.children[0])

            if varType in ['int', 'char']:
                self.add('\t mov \t eax, [{}]'.format(tree.children[0]))
                self.add('\t call \t print_{}'.format(varType))
            elif varType == 'bool':
                self.add('\t mov \t eax, [{}]'.format(tree.children[0]))
                self.add('\t call \t print_int')

        elif tree.data == 'NUMBER':
            self.add('\t mov \t eax, {} '.format(tree.children[0]))
            self.add('\t call \t print_int')

        elif tree.data == 'BOOL':
            self.add('\t mov \t eax, {} '.format((tree.children[0]=='true')+0))
            self.add('\t call \t print_int')

        elif tree.data == 'QCHAR':
            self.add("\t mov \t eax, '{}'".format(tree.children[0]))
            self.add('\t call \t print_char')


    def process_read(self, tree):
        readToVar = tree.children[0]
        varName = readToVar.children[0]
        varType = find_type_of_var(tree, varName)
        if varType == 'int':
            self.process_print_string('readint')
            self.add('\t call \t read_int')
            self.add('\t mov \t [{}], eax \t\t; Store read val'.format(varName))
        elif varType == 'char':
            self.process_print_string('readchar')
            self.add('\t call \t read_char')
            self.add('\t mov \t [{}], eax \t\t; Store read val'.format(varName))



    # helper function
    def assemble_children(self, tree):
        for child in tree.children:
            self.assemble_loop(child)

    def process_program(self, tree):
        self.assemble_children(tree)

    def process_function_declaration(self, tree):
        funReturnType = tree.children[0]
        funName = tree.children[1]

        # update labelmaker
        self.labels.fname = funName

        if funName == 'main':
            funName = '_asm_main' # linker entry point
        funParams = tree.children[2]
        funBody = tree.children[3] # block

        comment = ';\n; FUNCTION DECLARATION: {} {} ('.format(funReturnType,funName)
        for fparam in funParams.children:
            comment += '{} {},'.format(fparam.children[0],fparam.children[1])
        comment += ') {...}\n;'
        self.add(comment)

        self.add('; Offsets for formal parameters')
        i = 8
        for fparam in funParams.children: # FORMAL PARAMETERS +8 +12 +16
            fpType = fparam.children[0]
            fpName = fparam.children[1]
            self.add('%define {} ebp+{} \t\t; {} {}'.format(fpName,i,fpType,fpName))
            i += 4

        self.assemble_loop(funBody.children[0]) # assemble var decls

        self.add('; START FUNCTION BODY')
        self.add(funName + ":")
        self.add('\t enter \t 0,0 \t\t; Routine: push ebp /  mov ebp,esp')
        self.add('\t pusha')

        self.assemble_loop(funBody.children[1]) # assemble statements

    def process_block(self, tree):
        variables = tree.children[0]

        #self.assemble_loop(variables)
        for v in variables.children:
            label = self.add_bss(v.children[1])

        stmts = tree.children[1]

        for stmt in stmts.children:
            self.assemble_loop(stmt)

    def process_var_decls(self, tree):
        self.add("; Offsets for local variables ")
        i = 0
        for var in tree.children:
            i += 4
            self.add("%define {} ebp-{} \t\t; {} {}".format(var.children[1],i,var.children[0],var.children[1]))
        if(i < 0):
            self.add("\t sub \t ESP, " + str(-i) + "\t\t ; Adjust stack pointer to reserve space")


    def process_function_call(self, tree):
        targetFun = tree.children[0]
        if targetFun == 'main':
            targetFun = '_asm_main' #entry linker point
        argCount = 0
        for arg in tree.children[1:]:
            self.add('\t push \t dword {}'.format(arg.children[0])) # bool, char int?
            argCount += 1
        self.add('\t call \t {}'.format(targetFun))
        if argCount > 0:
            self.add('\t add \t esp, {} \t\t; Remove pushed args from stack'.format(4 * argCount))

    def process_return(self, tree):
        if tree.children[0] == 'void':
            self.add('\t popa')
            self.add('\t mov \t eax, 0 \t\t ; return back to C')
            self.add('\t leave \t\t; Routine: mov esp,ebp / pop ebp')
            self.add('\t ret')

        elif tree.children[0].is_leaf():
            if tree.children[0].data == 'VAR':
                self.add('\t mov \t eax, [' + str(tree.children[0].children[0]) + ']\t\t; Return value via EAX') # same
            else:
                self.add('\t mov \t eax, ' + str(tree.children[0].children[0]) + '\t\t; Return value via EAX') # same
            self.add('\t leave \t\t; Routine: mov esp,ebp / pop ebp')
            self.add('\t ret')


    def process_math(self, tree):
        left = tree.children[0]
        # calculate left value
        if left.data == 'NUMBER':
            leftvalue = str(left.children[0])
        else:
            leftvalue = '['+left.children[0]+']'

        # same for right value
        right = tree.children[1]
        if right.data == 'NUMBER':
            rightvalue = str(right.children[0])
        else:
            rightvalue = '['+right.children[0]+']'

        op = self.binops.get(tree.data)

        self.add('\t mov \t eax, {} \t\t; Left operand'.format(leftvalue))
        if op == 'imul':
            #self.add('\t mov \t ebx, {} \t\t ; Right operand'.format(rightvalue))
            self.add('\t {0} \t eax, {1} \t\t; {0} Right operand'.format(op, rightvalue))
            #self.add('\t mov \t eax, ecx')
        else:
            self.add('\t {0} \t eax, {1} \t\t; {0} Right operand'.format(op, rightvalue))

        #If we execute the code to place the left operand in the accumulator register,
        # and then execute the code to place the right operand in the accumulator register,
        # we will overwrite the value of the left operand with the value of the right operand
##        self.add('\t mov \t eax, '+ str(right.children[0])) # right operand!
##        self.add("\t push \t eax \t\t ; Push *right* operand on the stack")
##        self.add('\t mov \t eax, ' + str(left.children[0])) # left # TODO what if nodes
##        self.add("\t pop \t ebx \t\t ; Pop the *right* operand from the stack")
##        self.add("\t " + op + " \t eax, ebx \t\t ; Do the " + op + ", store result on stack")

    def process_condition(self, tree, label = None):
        left = tree.children[0]
        if left.data == 'NUMBER':
            leftvalue = str(left.children[0])
        else:
            leftvalue = '['+left.children[0]+']'

        right = tree.children[1]
        if right.data == 'NUMBER':
            rightvalue = str(right.children[0])
        else:
            rightvalue = '['+right.children[0]+']'

        comp = self.conds.get(tree.data)

        self.add('\t mov \t eax, {} \t\t'.format(leftvalue))
        self.add('\t cmp \t eax, {} '.format(rightvalue))

        if label:
            self.add('\t {} \t {} \t\t; Jump over else stmt'.format(comp, label))
        else:
            labelTrue = self.labels.getLabel()
            labelEnd = self.labels.getLabel()
            self.add('\t {} \t {}'.format(comp,labelTrue))
            self.add('\t mov \t eax, 0 \t\t; Set EAX to false')
            self.add('\t jmp \t '+labelEnd+'\t\t; Jump over true')
            self.add(labelTrue+':')
            self.add('\t mov \t eax, 1 \t\t; Set EAX to true')
            self.add(labelEnd+': \t\t; Allow false clause to jump over true clause')

    def process_assignment(self, tree):
        left = tree.children[0]
        right = tree.children[1]
        if not right.is_leaf():
            # if assingning value is a node, assemble that first, and result will be in EAX

            self.assemble_loop(right)
            rightvalue = 'eax'
        else:
            if right.data == 'VAR':
                rightvalue = '[{}]'.format(right.children[0])
            elif right.data == 'BOOL':
                rightvalue = (right.children[0]=='true')+0
            else:
                rightvalue = right.children[0]
        self.add('\t mov \t eax, {}'.format(rightvalue))
        self.add("\t mov \t [{0}], eax \t\t; {0} = {1}".format(left.children[0], rightvalue))

    def process_assignment_array(self, tree): pass
##        print "####",tree
##        arr = tree.children[0]
##        segment = '{} resd {}'.format(arr.children[0].children[0], arr.children[1].children[0])
##        self.bss.append(segment)

    def process_if_then(self, tree):
        self.add('; Begin IF THEN')
        # needs to jump over then clause child[2] so we need a label
        endlabel = self.labels.getLabel()
        cond = tree.children[0]
        if cond.data == 'BOOL':
            condvalue = '{}'.format((cond.children[0] == 'true') + 0)
        else:
            condvalue = '[{}]'.format(cond.children[0])

        #self.assemble_loop(tree.children[0]) # cond
        self.add( "\t mov \t eax, "+condvalue+" \t\t ; Pop value on the top of stack")
        self.add( "\t cmp \t eax, 0 \t\t ; Compare cond with 0")
        self.add( "\t jne \t " + endlabel + " \t\t ; Jump if popped value is not false")
        self.assemble_loop(tree.children[1]) # then
        self.add( endlabel + ": \t\t ; End if-then structure")

    def process_if_then_else(self, tree):
        self.add('; Begin IF THEN ELSE LOOP')
        endlabel = self.labels.getLabel() # "endif2"
        elselabel = self.labels.getLabel() # "else2"

        #self.process_condition(tree.children[0],elselabel) #cond
        if tree.children[0].data == 'BOOL':
            condition = str((tree.children[0].children[0] == 'true' )+ 0) # bool to 1/0
        else:
            condition = '[{}]'.format(tree.children[0].children[0])

        self.add( "\t mov \t eax, "+condition+" \t\t ; Load bool in eax")
        self.add( "\t cmp \t eax, 0 \t\t ; Compare expr with 0")
        self.add( "\t je \t " + elselabel + " \t\t ; Jump if popped value is false")
        self.assemble_loop(tree.children[1]) # then code
        self.add( "\t jmp \t " + endlabel + " \t\t ; Jump over else clause to end")
        self.add( elselabel + ": \t\t ; Begin Else code")
        self.assemble_loop(tree.children[2]) # else code
        self.add( endlabel + ": \t\t ; End if-then-else structure")

    def process_while(self, tree):
        condlabel = self.labels.getLabel() #"condlabel"
        endlabel = self.labels.getLabel() #"endwhile"
        self.add( condlabel + ": \t\t ; Begin condition of while")
        self.assemble_loop(tree.children[0])
        self.add( "\t cmp \t eax, 0 \t\t ; Compare cond res with 0")
        self.add( "\t je \t "+ endlabel + " \t\t ; End the while if false")
        self.assemble_loop(tree.children[1])
        self.add( "\t jmp \t " + condlabel + " \t\t ; Jump back to condition")
        self.add( endlabel + ": \t\t ; End while structure")

    def assemble_loop(self, tree):
        if type(tree) != Node:
            pass # do soemthing

        elif tree.is_leaf():
            pass#self.add('\t push \t '+str(tree.children[0]))

        elif tree.data == 'program':  #done
            self.process_program(tree)

        elif tree.data == 'fDecl': #done
            self.process_function_declaration(tree)

        elif tree.data == 'block': #done
            self.process_block(tree)

        elif tree.data == 'fCall': #done
            self.process_function_call(tree)

        elif tree.data == 'return': #done
            self.process_return(tree)

        elif tree.data == 'write': #fix
            self.process_write(tree)

        elif tree.data == 'read':
            self.process_read(tree)

##        elif tree.data == 'varDecl':
##            self.process_variable_declaration(tree)
        elif tree.data == 'varDecls':
            self.process_var_decls(tree)

        elif self.binops.has_key(tree.data): #fix
            self.process_math(tree)

        elif self.conds.has_key(tree.data): #
            self.process_condition(tree)

        elif tree.data == 'if' and len(tree.children) == 2: #done
            self.process_if_then(tree)

        elif tree.data == 'if' and len(tree.children) == 3: #done
            self.process_if_then_else(tree)

        elif tree.data == 'while': #done
            self.process_while(tree)

        elif tree.data == 'assign' and tree.children[0].data != 'VAR': # if not var
            self.process_assignment_array(tree)

        elif tree.data == 'assign': # if we get here, the value is not another node
            self.process_assignment(tree)

        else:
            for child in tree.children:
                self.assemble_loop(child)



        #process_write('readint')
        #readlabel = process_read()
        #add_data('readback', 'You entered: ')
        #process_write('readback')
        #process_write_int('['+readlabel+']')


    #add("\t%define n \t 5")
    #process_function_start('dickbutt')
    #process_print('dickbut')
    # pritn an int
    #add('\tmov dword [n], 69')
    #add('\tmov eax, [n]')
    #add('\tcall \t print_int')
    #process_function_end()
    #process_function_start(tree.children[0])
